# Цель
Консольная утилита, преобразующая архив с ДЗ в новый архив, 
который Ревизор готов принять и перенести из него комментарии в исходные файлы домашки.



# Способ применения
Минимальный полезный запуск
```
python autorv2.py путь-к-домашке.zip
```
создаст (перезапишет!) файл `путь-к-домашке.fN!F+G-E.zip`, который можно передать Ревизору.  
Вместо `N`, `F`, `G`, `E` будут подставлены числа, отражающие результат работы:  
    `N` - число файлов, в которые попали комменты,  
    `F` - число неточностей (**Можно лучше**),  
    `G` - число удач (**Отлично**),  
    `E` - число ошибок (**Надо исправить**).



# Основные идеи


## (1) Ревьювер сохраняет свои навыки в "приватных знаниях"

1. Настройки знаний размещаются в **приватных** json-подобных файлах.  
Для одной домашки собираются знания из нескольких файлов.  
Например, можно выносить претензии к нарушениям языка/РЕР8 в файл, который подхватывать для всех домашек.  
Например, можно для серии домашек подхватывать файл от предыдущей домашки.  
2. Порядок сборки файлов знаний указывается в **публичных** или **приватных** настройках АР.  
Такие настройки (точнее их умолчательный вариант) публикуются вместе с исполняемым кодом.


## (2) Способы поиска
У ревьювера есть выбор для организации поиска мест, требующих комментирования.
Он может опираться на поиск регулярками в тексте модуля и/или анализировать элементы AST-дерева, 
то есть на наличие и свойства описанных объектов.

1. Можно писать только Питон-регулярки.  
За-и-против:  
    (+) Для "прокачанных" не потребуется переучиваться.  
    (+) Не потребуются символы, которых нет на клавиатуре.  
    (-) Будут появляться громоздкие и/или малопонятные конкструкции.  
    Например, регулярка, захватывающая до парной фигурной скобки,   
    `\{[^\{\}]*?(?:\{[^\{\}]*?(?:\{[^\{\}]*?\}[^\{\}]*?)*?\}[^\{\}]*?)*?\}`.  
    (-) Обязательно выполнять экранирование точек, скобок, обратных слешей и прочих re-символов,  
    если они есть в искомом фрагменте.  
1. Чтобы избегать громоздкости регурялок и экранирований, АР предлагает применять сахара.  
    **Сахар - часть поисковой разметки, которая позже станет регуляркой.**  
Ближайший аналог - макрос в С/С++.
Сахара специально записываются символами, которые точно не встречаются в re-языке 
(и еще вряд ли встретятся в исходниках).
За-и-против:  
    (+) Поисковый шаблон компактный, а значит более понятный.  
    (+) Доступны доп-сервисы от АР (например, запоминание номеров строк).  
    (-) Смыслы сахар-знаков неочевидны.
    (-) Нужно копировать знаки  из доки или из применений.  

   На месте сахара может появится примитивная регулярка. Например,  
    `■` подменяется на `.+` и позволяет захватывать любые символы в текущей строке.  
Сахар может заменяться на громоздкое re-выражение. Например,  
    `{‡}` дает захват до парной фигурной скобки (см выше).  
Но сахарые подмены могут через АР достигать и более сложных целей.  
Они могут захватывать окрущающие символы, чтобы конечная регулярка их учитывала:  
    `◊` позволяет построить поиск нескольких подряд строк с таким же отступом, как перед этим знаком.  
    `...╣фраза╣`/`╠фраза╠...` позволяет построить поиск фрагмента без указанной фразы после/перед `...`.  
Есть еще более продвинутые сахара.  
    `↓1` позволяет АР запоминать номер строки исходника, где встретился такой сахар.  
    Позже этот номер можно будет вставить в комментарий и/или использовать в логике.  

   Вставить сахар в шаблон можно несколькими способами:
   - Через недоступный с клавиатуры **сахар-символ**, такой как `■`.  
   - Через указание **Юникод-имени** внутри штатной конкструкции: `'\N{BLACK SQUARE}'`.  
У *всех* символов есть такие имена - их можно узнать через `unicodedata.name('■')`.  
   - Через указания **АР-имени** внутри конструкции `<~ANY_IN_ROW>`.  
У всех сахаров (или их частей) есть такие имена.  

   Чтобы совместить "плюсы" от всех за-и-против, АР предоставляет возможность внутри 
одного поискового шаблона иметь зоны "чистых регулярок" и зоны "сахарной разметки".  
Одна из зон будет считаться главной, а части второй будут размещаться в **изоляторах**, 
через заключение в лапки `«...»`.  
Какая разметка попадет в изолятор, настраивается:  
   - По умолчанию АР считает весь шаблон сахарным, а внутри изоляторов видит регулярки.  
   - Настройкой можно переключить АР на ожидание регулярок вне изоляторов и сахаров внутри изоляторов.  
   - Настройка доступна для одного/группы/всех поисков.  
1. AST-дерево и шаблоны поиска его узлов.  
Можно писать XPath-выражения на поиск элементов в AST-дереве, преобразованном в XML.  
За-и-против:  
    (+) Работа с понятыми объектами модуль/класс/функция/параметр/переменная/значение/...  
и их понятными свойствами тип/место-в-исходнике/...  
    (+) Работа с могучим XPath-языком для указания поисков в дереве.  
    (-) Необходимость изучить детали (много их) модуля `ast` (см [ast-бриф](#ast_xml_brief), [Питон↑](https://docs.python.org/3/library/ast.html#module-ast)).  
    (-) Необходимость представлять структуру AST-дерева для ожидаемого кода из домашки.  
    (-) Необходимость изучить XPath-язык (см [XPath-бриф](#xpath-brief), [Питон↑](https://docs.python.org/3/library/xml.etree.elementtree.html#xpath-support), [w3.org↑](https://www.w3.org/TR/1999/REC-xpath-19991116/)).  
    (-) Теряется возможность запоминать промежуточные подфрагменты.  

1. Можно дополнять поиски регулярками/сахарами через анализ места найденных ими фрагментов в AST-дереве.  
Например, будет полезно знать, что фрагмен оказался целиком внутри текстового литерала или внутри комментария.  
Еще полезно, например, учесть, что фрагмент оказался внутри подходящего класса/метода/функции.

## (3) Минимальным элементом "знаний" является АР-словарь
Цель такого [АР-словаря](#rv-dict) - указать для одной претензии "что найти" и "как прокомментировать".  

**Пример.**  
Нужно искать в домашке выражения вида  
    `kwargs={'идентификатор': любой-код}`  
При этом запоминать `любой-код` и номер строки, где находится `kwargs`.  
Нужно сформировать комментарий вида  
    `Рекомендую в строке ... заменить kwargs={'id': ...} на args=[...].`  
  
Вот АР-словарь c **сахар-символами**, который может это сделать
```python
dict(
    level='F', 
    patten='''kwargs↓1={'‡‡': ≤key≡‡≥}''',
    note='Рекомендую в строке ↓1↓ заменить {{patten_rt.g}} на args=[{{patten_rt.g.key}}].',
)
```
Тут применены  
    `↓1` - **номер строки** (АР его запомнит).  
    `‡‡` - **идентификатор**, то есть буквы-цифры-_-точки.  
    `≤` `≡` `≥` - **именованная группа**: начало имени, завершение имени и начало поиска, конец поиска.  
    `‡` - **стяжка**, минимальный набор любых символов.  
Конструкция `≤key≡‡≥}` запоминает под именем `key` все что захватит стяжка, то есть до ближайшего `}`.  
  
Вот как этот же АР-словарь записывается с **сахар-именами**, то есть без спец-знаков:  
    `↓` стал `<~ROW>`,  
    `‡‡` стал `<~ID0>` (0 показывает, что захват может быть пустой),  
    `≤` `≡` `≥` стали `<~GRP_NM>` `<~GRP_OP>` `<~GRP_CL>`,  
    `‡` стал `<~TIE>`.  
```python
dict(
    level='F', 
    patten='''kwargs<~ROW>1={'<~ID0>': <~GRP_NM>key<~GRP_OP><~TIE><~GRP_CL>}''',
    note='Рекомендую в строке <~ROW>1<~ROW> заменить {{patten_rt.g}} на args=[{{patten_rt.g.key}}].',
)
```

Вот как этот же словарь можно переделать **на регулярки** вместо всех сахаров, 
кроме запоминания номера строки, который помещен в **изолятор** `«↓1»`  
    `‡‡` стал `[\w\.]*`,  
    `≤` `≡` `≥` стали `(?P<` `>` `)`.  
    `‡` стал `(?s:.*?)`,  
```python
dict(wait_re='T',
    level='F', 
    patten=r'''kwargs«↓1»=\{'[\w\.]*': (?P<key>(?s:.*?))\}''',
    note='Рекомендую в строке ↓1↓ заменить {{patten_rt.g}} на args=[{{patten_rt.g.key}}].',
)
```
Кроме замены сахаров потребовались еще доделки:  
    `wait_re='T'` - указание на "сахара будут в изоляторе",  
    добавление модификатора `r'''...'''`,  
    экранирование фигурных скобок.  

Применение всех трех АР-словарей одинаковое.  
Если в исходнике в строках 123..126 есть код  
```python
123   ... = reverse(
124       'new:edit', 
125       kwargs={'id': post_id}
126   )
```  
то АР **добавит комментарий** к строке 125  
```python
123   ... = reverse(
124       'new:edit', 
125       kwargs={'id': post_id}
      Рекомендую в строке 125 заменить kwargs={'id': post_id} на args=[post_id].
         Можно лучше
126   )
```  

Если упростить задачу.  
    Искать в домашке выражения параметры вида  
        `kwargs=`  
    Сформировать комментарий вида  
        `Рекомендую заменить kwargs={...} на args=[...].`  
Тогда такой АР-словарь c **XPath-шаблоном** подойдет  
```python
dict(level='F', 
    patten='''//keyword[@arg="kwargs"]''',
    note='''Рекомендую заменить kwargs={...} на args=[...].''',
)
```  


    
## (4) Приватная адаптация поисков

Ревьювер волен применять АР2 как есть, либо развивать его самостоятельно.  
Кроме файлов знаний с АР-словарями, ревьювер может создавать личные расширения/плагины для АР.  

### Cвои свободные и/или плагинные сахара
Простейший способ адаптировать поиск под свои потребности - добавить **свои сахара**.  

Для этого нужно знать, что сахарные знаки делятся на
- [Зашитые](#in-sugar) в код АР:  
    `«` `»` `↓` `≤` `≡` `≥`.  
Они задействованы в собственных алгоритмах АР.  
- [Плагинные](#plug-sugar), дополняющие код АР:  
    `‡` `(‡)` `[‡]` `{‡}` `╠` `╣` `◊` `!<` `¦` `>!`.  
Они задействованы через API для сахаров.  
- [Свободно](#free-sugar) заменяемые/дополняемые. 
Каждый из них подменяется на фиксированную регулярку.  
В штатный набор входят:  
    `‡‡` `□` `■` `○` `▪` `▫` `†`.  
Такие знаки, их имена и регулярки перечислены в json-подобном файле (фактически в таблице)  
    `autorv2_free_sugars.py`,  
который АР2 подхватывает после запуска.  

Кроме того, нужно учитывать:  
- Замены "свободных" выполняются раньше замен "плагинных", которые - раньше "зашитых".  
- В результате замены "свободных"/"плагинных" могут появиться новые сахара, в том числе зоны изоляции.  
- Подмены будут продолжаться пока в сахарных зонах не кончатся сахара.  

**Пример**. 
Штатный файл со свободными выглядит так
```python
free_sugars = [
    ...
    ['†'    ,'QUOTE'    ,'[\'"]']       # Одна из кавычек
]
```
Если его дополнить
```python
free_sugars = [
    ...
    ['†'    ,'QUOTE'    ,'[\'"]']       # Одна из кавычек
    ['⌂'    ,'HOME'     ,'†«[home]+»†'] # Дом, милый дом!
]
```
то в поисковых шаблонах можно будет через `⌂`/`<~HOME>` искать  
    <кавычка><буквы слова home><кавычка>
  
### Cвои плагины.
(*ДОКУМЕНТАЦИЯ В РАЗРАБОТКЕ*)



# Готовые решения

## Порядок применения АР2 руками <a name=hand-use></a>

1. Подготовить хотя бы один файл-знаний.  
АР2 по умолчанию ищет знания в своей подпапке `skills`.  
Например, можно создать файл `skills/skill_of_python.py` с таким наполнением 
(ловим переносы символом `\`, [подробности](#ready_continue) настройки)  
   ```python
   {
     '*.py':[
       dict(level='E', wo_strip='T', repeats='all'
            patten='\\\n', 
            note=['Так низяяяяя! Заключайте в скобки.','Смотри выше',],
       ),
     ],
   }
   ```
1. Указать в АР2-настройках этот файл для проверяемой домашки.  
Например, если это ДЗ Бот, то внутри файла `def_opts.py` в ветке `skills` нужно показать созданный файл знаний:  
   ```python
       ...
       skills=d(
           bot=d(
               main_dirs_in_zip=['homework_bot-master', 'bot-master',],
               skills=['skills/skill_of_python.py',], # <<<<<<<<<<<<<<<<
           ),
       ),
       ...
   ```
   Этот шаг можно заменить на опцию при вызове - см ниже.
1. В Ревизоре на вкладке Ревью нажать верхнюю кнопку "скачать код" 
![image](https://github.com/kvichans/autorv2_doc/assets/7419630/259e97c9-e698-425a-ad29-284623e34ab4) 
или нижнюю ссылку "Скачать код"  
![image](https://github.com/kvichans/autorv2_doc/assets/7419630/ad444643-544e-46e6-8d74-5cec55a49af1)  
1. Сохранить zip-файл в подходящей папке.  
1. Запустить АР2 в консоли через  
   ```bash
   > python autorv2.py путь-к-домашке.zip
   ```
   Можно вместо правки настроек прямо тут указать файл знаний  
   ```bash
   > python autorv2.py путь-к-домашке.zip -o "skills/bot/skills=['skills/skill_of_python.py']"
   ```
   Рядом с `путь-к-домашке.zip` будет создан файл с комментариями вида `путь-к-домашке.f1!1+0-0.zip`.  
1. В Ревизоре нажать на кнопку  
![image](https://github.com/kvichans/autorv2_doc/assets/7419630/c3a07a28-b649-47c5-812a-2af5c53d7a63)  
и выбрать созданный файл `путь-к-домашке.f1!1+0-0.zip`.


## Порядок применения АР2-Монитора <a name=monitor-use></a>

1. Подготовить файл-знаний `знания.py` (например, как в [ручном запуске](#hand-use)).
1. Указать эти знания в АР2-настройках для каждой конкретной домашки. Например, для Бота
   ```python
       ...
       skills=d(
           bot=d(
               main_dirs_in_zip=['homework_bot-master', 'bot-master',],
               skills=['skills/знания.py',], # <<<<<<<<<<<<<<<<
           ),
       ),
       ...
   ```
1. Один раз запустить Монитор в консоли/демоне/сервисе  
   ```bash
   > python autorv2.py -m папка-всех-студентов
   ```
   При доработках в `знания.py` Монитор перезапускать не нужно - он сам подхватит изменения.  
При доработках АР2-настроек перезапуск нужен.
1. Теперь можно сохранять из Ревизора zip-файл с домашкой в  
    `папка-всех-студентов`  
или в  
    `папка-всех-студентов/студент`  
    NB! Монитор не создает подпапку `студент` - это ручная работа для ревьювера.  
Монитор  
    отследит появление zip,  
    запустит АР2.  
Для ревьювера это будет выглядеть так, будто **zip-файл с комментариями появится сам**.  
Останется подхватить его в Ревизоре так же, как при [ручном запуске](#hand-use).  
1. Если Монитор настроен с запуском дифф-тула, то после сохранения zip в папку  
    `папка-всех-студентов/студент`  
Монитор распакует его в новую подпапку - ее имя сформируется из главной папки в zip и номера итерации.  
Например, для Бота это будут папки  
    `папка-всех-студентов/студент/homework_bot-master_1`,  
    `папка-всех-студентов/студент/homework_bot-master_2` и тд.  
Монитор запустит дифф-тул, чтобы показать разницу последней и предыдущей итераций.

## Заготовки для типовых ситуаций

### Применение \ для продолжений кода <a name=ready_continue></a>
**АР-словарь с сахар-символами**:
```python
dict(level='E', wo_strip='T', repeats='all',
    patten='↓1\\\n',
    note=['Так низяяяяя! В скобки их!', 'Смотри коммент к строке ↓1↓.',],
),
```
**АР-словарь с сахар-именами**:
```python
dict(level='E', wo_strip='T', repeats='all',
    patten='<~ROW>1\\\n',
    note=['Так низяяяяя! В скобки их!', 'Смотри коммент к строке <~ROW>1<~ROW>.',],
),
```
*Пояснения.*  
– `wo_strip='T'` - не удалять пробельные символы из `patten`.  
– `repeats='all'` - комментировать все случаи.  
– `↓1` `<~ROW>1` - запомнить номер строки с первым найденным случаем.  
– `↓1↓`  `<~ROW>1<~ROW>` - вставить номер запомненной строки.  
**Размещение**: в файле знаний для проверки Питона  
```python
{
  '*.py':[тут],
}
```
**Реакции**:  
– Первый случай в каждом модуле будет с описанием проблемы и советом.  
– Остальные случаи в каждом модуле будут ссылками на совет.  

### Нарушение порядка импортов
Поиск случаев, когда импорты установленных либ идут позже импортов из проекта.  
**АР-словарь с сахар-символами**:  
```python
dict(level='E', 
    patten=['''
from !<.¦post¦blog¦app>!■○
from !<django¦rest¦flask¦fast>!
''',], 
    note='А как же РЕР8? Учили вас, учили...',
),
```
**АР-словарь с сахар-именами**:
```python
dict(level='E', 
    patten=['''
from !<.¦post<~VAR>blog<~VAR>app>!<~FILLER><~BLANKS0>
from !<django<~VAR>rest<~VAR>flask<~VAR>fast>!
''',], 
    note='А как же РЕР8? Учили вас, учили...',
),
```
*Пояснения.*  
– `!<.¦post¦blog¦app>!` `!<.<~VAR>post<~VAR>blog<~VAR>app>!` - поиск одного из указанных простых фрагментов.  
– `■` `<~FILLER>` - любые символы в пределах этой же строки, то есть окончание импорта.  
– `○` `<~BLANKS0>` - любые пробельные символы, например, пустые разделяющие строки.  
**Реакции**:  
– В каждом модуле один раз указывается на недостаток в импортах.  

### Нарушение 2-сдвигов в шаблонах
(*В разработке*)
### Неуместные print() в рабочих модулях
(*В разработке*)
### Нарушенный порядок поле-Meta-метод в модели
**Размещение**: в файле знаний для проверки проектов с моделями  
```python
{
  'defaults': dict(level='E', repeats='all',),
  '.*models.py':[тут],
}
```
**АР-словари с сахар-знаками**:  
```python
dict( 
    patten=['''
class ■
    ◊
    def ↓2■
    ◊
    class Meta↓1■
''',], 
    note=['Не ложьте Мета за методы (см с.↓2↓)!', ' См выше (строка ↓1↓).'],
),
dict( 
    patten=['''
class ■
    ◊
    class Meta■
    ◊
    ‡‡ = ↓1■
''',], 
    note=['Не ложьте Мета перед полями!', ' См выше (строка ↓1↓).'],
),
dict( 
    patten=['''
class ■
    ◊
    def ↓2■
    ◊
    ‡‡ = ↓1■
''',], 
    note=['Не класьте поля за методы (см с.↓2↓)!', ' См выше (строка ↓1↓).'],
),
```
**АР-словари с сахар-именами**:  
```python
dict( 
    patten=['''
class <~FILLER>
    <~GAP>
    def <~ROW>2<~FILLER>
    <~GAP>
    class Meta<~ROW>1<~FILLER>
''',], 
    note=['Не ложьте Мета за методы (см с.<~ROW>2<~ROW>)!', ' См выше (строка <~ROW>1<~ROW>).'],
),
dict( 
    patten=['''
class <~FILLER>
    <~GAP>
    class Meta<~FILLER>
    <~GAP>
    <~ID0> = <~ROW>1<~FILLER>
''',], 
    note=['Не ложьте Мета перед полями!', ' См выше (строка <~ROW>1<~ROW>).'],
),
dict( 
    patten=['''
class <~FILLER>
    <~GAP>
    def <~ROW>2<~FILLER>
    <~GAP>
    <~ID0> = <~ROW>1<~FILLER>
''',], 
    note=['Не класьте поля за методы (см с.<~ROW>2<~ROW>)!', ' См выше (строка <~ROW>1<~ROW>).'],
),
```
*Пояснения.*  
- `'defaults': dict(level='E', repeats='all',)` - общее задание ключей `level` и `repeats` для всех АР-словарей.  
- `■` `<~FILLER>` - любые символы в пределах этой же строки.  
- `◊` `<~GAP>` - любое количество (в тч нулевое) строк с таким же отступом (тут - 4 пробела).  
- `‡‡` `<~ID0>` - идентификатор, т.е. слово из букв-цифр-_-точек. `‡‡ = ` ловит имя поля.  
- `↓1` `<~ROW>1` - запомнить номер строки с первым найденным случаем.  
- `↓1↓` `<~ROW>1<~ROW>` - вставить номер запомненной строки.  

**Реакции**:  
- В модуле с моделями указывается на все неудачные взаимные размещения полей/Meta/методов.  
Первый раз подробно. Остальные ссылкой на первый. 

### Не хватает локализации модели
Поиск случаев, когда в `Meta` у модели нет переводов.  
**Логика поисков**  
    Если не найден `verbose_name` внутри `Meta`,  
    но найден сам `Meta` (или хотя бы класс модели), где он должен быть,  
    то нужен комментарий у `Meta` (или у класса модели).  

**Размещение**: в файле знаний для проверки проектов с моделями  
```python
{
  '.*models.py':[тут],
}
```
**Варианты АР-словарей**  
  
**(Вариант 1) XPath**-шаблоны в `patten` заданы **списком**  
```python
dict(level='E', note='Когда ж локализации у моделей будут?',
    patten=[
      '//ClassDef[@name="Post"]' '//ClassDef[@name="Meta"]' '//*[@id="verbose_name"]',
      '//ClassDef[@name="Post"]' '//ClassDef[@name="Meta"]',
      '//ClassDef[@name="Post"]',
    ],
    formula='not {{patten_rt._0}} and ({{patten_rt._1}} or {{patten_rt._2}})', 
    position='max({{patten_rt._1.top}}, {{patten_rt._1.top}})',
),
``` 
*Пояснения.*  
- Шаблоны начинаются на `/` - это XPath-запросы к AST-XML-дереву.  
- `formula='...'` - текст формулы, которая после eval() скажет "успешен ли поиск".  
- `position='...'` - текст формулы, которая после eval() скажет "номер строки, куда коммент вставлять".  
- `//ClassDef[@name="Post"]` - ловим класс `Post` от корня дерева.  
- `//ClassDef[@name="Meta"]` - ловим вложенный класс `Meta`.  
- `//*[@id="verbose_name"]` - ловим любой узел внутри `Meta` с таким атрибутом, то есть поле.  
Можно было написать полный путь  
    `/body/Assign/targets/Name/*[@id="verbose_name"]`  
но на результат это не повлияет.  
- `{{patten_rt._0}}` набор найденных фрагментов от первого шаблона.  
Вычисление  
    `not {{patten_rt._0}}`  
будет давать Да, если поиск провалился (фрагменты не найдены).  
Вычисление  
    `({{patten_rt._1}} or {{patten_rt._2}})`  
будет давать Да, если успешен хоть один из поисков по второму или третьему шаблону.  
- `{{patten_rt._1.top}}` - номер верхней строки у фрагмента найденного вторым шаблоном.  
- Так как `.top` для ненайденных возвращает -1, 
`max()` даст либо номер строки с `class Post` (если нет `Meta`), либо номер строки с `class Meta`.  

**(Вариант 2) Сахар**-шаблоны в `patten` заданы **словарем**
```python
dict(level='E', note='Когда ж локализации-то будут?',
    patten=dict(good='''
class Comment■
    ◊
    class Meta:‡
        ◊
        verbose_name =''',
                only_meta='''
class Comment■
    ◊
    class Meta''',
                only_clss='''
class Comment''',
    ),
    formula='not {{patten_rt.good}} and ({{patten_rt.only_meta}} or {{patten_rt.only_clss}})', 
    position='max({{patten_rt.only_meta.btm}}, {{patten_rt.only_clss.btm}})',
),
```
*Пояснения.*  
- `■` - любые символы в пределах этой же строки.  
- `◊` - любое количество (в тч нулевое) строк с таким же отступом (тут 4/8 пробелов).  
Внимание! Такая разметка опирается на предположение, что в классе будет соблюдаться дисциплина отступов.  
- `formula='...'` - текст формулы, которая после eval() скажет "успешен ли поиск".  
- `position='...'` - текст формулы, которая после eval() скажет "номер строки, куда коммент вставлять".  
- `{{patten_rt.good}}` инфа про результат поиска шаблоном `good=...`.  
- Вычисление  
    `not {{patten_rt.good}}`  
будет давать Да, если поиск провалился (инфа пустая).  
- Вычисление  
    `({{patten_rt.only_meta}} or {{patten_rt.only_clss}})`  
будет давать Да, если если найден класс с Мета или только сам класс `Comment`.  
- `{{patten_rt.only_meta.btm}}` номер последней строки для найденного фрагмента (тут от шаблона `only_meta=...`).  
- Так как `.btm` для ненайденных возвращает -1, вычисление  
    `max({{patten_rt.only_meta.btm}}, {{patten_rt.only_clss.btm}})`  
даст нижнюю строку от одного из найденных фрагментов.
    

### Не хватает локализации поля в модели
Поиск случаев, когда у поля `ForeignKey` в модели нет перевода.  
**Логика поисков**  
    Если не найден `verbose_name` внутри `author=models.ForeignKey()` или `author=ForeignKey()`,  
    то нужен комментарий к `author=`.  

**Размещение**: в файле знаний для проверки проектов с моделями  
```python
{
  '.*models.py':[тут],
}
```
**АР-словари**:  
  
**XPath**-шаблоны в `patten` заданы **списком**  
```python
dict(level='E', note='Когда ж локализация у поля будет?',
    patten=[
      '//Assign[targets/Name[@id="author"]]',
      '//Assign[targets/Name[@id="author"]]'
       '/value/Call[//*[@attr="ForeignKey"] or //*[@id="ForeignKey"]]'
        '//keyword[@id="verbose_name"]',
    ],
    formula=' {{patten_rt._0}} and not {{patten_rt._1}}', 
    position='{{patten_rt._0.top}}',
),
``` 
*Пояснения.*  
- Шаблоны начинаются на `/` - это XPath-запросы к AST-XML-дереву.  
- `//Assign[targets/Name[@id="author"]]` - ловим код `author=` от корня дерева.  
- `'/value/Call[//*[@attr="ForeignKey"] or //*[@id="ForeignKey"]]` - ловим `=model.ForeignKey()` или `=ForeignKey()`.  
- `'//keyword[@id="verbose_name"]'` - ловим параметр внутри этого вызова.  
- `{{patten_rt._0}}` набор найденных фрагментов от первого шаблона.  
Вычисление  
    `not {{patten_rt._1}}`  
будет давать Да, если поиск провалился - `verbose_name` не найден для второго шаблона.  
- `{{patten_rt._0.top}}` - номер верхней строки у фрагмента найденного первым шаблоном.  

### Не хватает типа у извлекаемого параметра при регистрации маршрута
(*В разработке*)
### Неудачное имя параметра при объявлении маршрута
(*В разработке*)
### Неуместное применение фильтра вместо опоры на related_name
(*В разработке*)
### Избыточное дублирование деталей кода
(*В разработке*)
### Размещение действий в неуместном методе
(*В разработке*)
### Ошибочное параллельное применение logger.error() и logging.error()
(*В разработке*)



# Технические детали  


## Структура словаря знаний (АР-словарь) <a name=rv-dict></a>  

**Внедряемые ключи** <a name=implant></a>   
Любой ключ, если не задан явно, может получить значение из окружающего словарь набора.  
Например, его можно указать  
    в `defaults` на уровне [файла](#rv-file) с этим словарем,  
    в опции [запуска](#opts).  
То есть это "вынесение за скобки" для повторяющихся значений.  

**Обязательные ключи** <a name=need-keys></a>  

- `level`/`levl` <a name=levl></a>  
    `'G'`|`'F'`|`'E'` - **G**ood/похвала, **F**alse/совет, **E**rror/ошибка.  
**Уровень** выходного комментария.  
- `patten`/`pttn` <a name=pttn></a>  
    строка|список-строк|словарь-со-строковыми-значениями  
**Шаблон(ы)** для поиска.  
Один шаблон для поиска может быть  
    регуляркой/сарахом (может начинаться с `re:`)  
или  
    XPath-выражением для AST-дерева (может начинаться с `xpath:`).  
Если нет явного указания `re:`/`xpath:`, то  
    шаблоны, начинающиеся на `/` считаются `xpath:`,  
    остальные `re:`.  
В случае успешного поиска (расчет успеха может уточняться в формуле из `formula`)  
формируется номер строки (ее расчет может уточнять в формуле из `position`) для вставки комментария.  
После поиска порождает runtime-[след](#patten_rt) `patten_rt`.  
- `note` <a name=note></a>  
    строка|список-строк|словарь-со-строковыми-значениями  
Комментарий или **варианты комментариев**.  
Для первого найденного случая применяется первый комментарий, для второго - второй и т.д.  
Если случев больше и если `repeats` задан как `'all'`, то будет применяться последний вариант.  
После поиска порождает runtime-[след](#note_rt) `note_rt`.  
    
**Ожидаемые ключи** <a name=waited-keys></a>  

- `repeats`/`rpts` <a name=rpts></a>  
    `'one'`|`'all'`|`'as-note'`  
    Умолчание: `'as-note'`  
Настройка **повторных** комментирований в пределах одного файла-исходника.  
`'one'` - комментировать только первый случай.  
`'all'` - комментировать все найденные случаи, повторяя последний элемент `note` при необходимости.  
`'as-note'` - комментировать не больше, чем вариантов в `note`.  
- `formula`/`frml` <a name=frml></a>  
    Умолчание: `''`  
Текст формулы, по которой будет eval-вычисляться **успех поиска**.  
Умолчание - "есть хоть одна находка" - по формуле `any(patten_rt.values())`.  
Например, при настройке  
    `formula='{{patten_rt._0}} and {{patten_rt._2}}'`  
поиск будет успешным, если первый и третий шаблон успешны.
- `position`/`posi` <a name=posi></a>  
    Умолчание: `''`  
Текст формулы, по которой будет eval-вычисляться **номер строки** исходника для вставки.  
Умолчание - "самая нижняя строка у найденных фрагментов" - по формуле `max(p.e for p in patten_rt.values())`.  
Например,  
    `position='min({{patten_rt._0.top}}, {{patten_rt._1.btm}}, -1)'`.  
- `wo_strip` <a name=wo_strip></a>  
    Умолчание: `''` - выполнять strip-ы.  
Флаг для **пропуска** `.strip()` для всех значений у `patten` и `note`.  
Умолчание позволяет свободнее оформлять знания, но может мешать точному поиску/вставке.  
- `wait_re` <a name=wait_re></a>  
    Умолчание: `''` - ожидать сахар.  
Флаг для переключение c ожидания сахара на **ожидание регулярки**.  
Умолчание настроено на то, что регулярки появляются только внутри `«...»`.  
При любом непустом значении сахар ожидается внутри `«...»`.  
- `end_sign` <a name=end_sign></a>  
    Умолчание: `''`  
Завершающее дополнение для комментария.  
Позволяет добавлять **"подпись АР"** ко всем комментариям.  
Так как в разных файлах могут быть разные подписи, будет видно из какого файла АР брал знания.  

- `name` (идентификатор) <a name=name></a>  
    Умолчание: `''`  
Имя контекстной **переменной для подстановок** в другие знания.  
Например, `name='имя'` позволит подставлять в других АР-словарях  
    `{{имя.level}}` или `{{имя.note}}` или `{{имя.note_rt._1 }}`.  
Можно организовывать цепочки знаний и/или условные комментирования.  

**Runtime-след - ключи, доступные только после выполнения поиска** <a name=rt-keys></a>  
Для каждого нового исходника эти ключи заполняются заново.  

- `patten_rt`/`pttn_rt` <a name=pttn_rt></a>  
    словарь словарей  
Словарь (мб с пустыми элементами!), содержащий инфо про **найденные фрагменты** *для первого случая* 
(и первый и все остальные случаи попадают в `usages`).  
Если `patten` был задан списком, то ключами станут `_позиция`:  
    `{'_0':{инфо},'_1':{},}`  
Если `patten` уже был словарем, то ключи сохранятся.  
Внутри словаря инфо будут такие ключи  
– `'top':номер-строки-на-начало-найденного-фрагмента`,  
– `'btm':номер-строки-на-конец-найденного-фрагмента`,  
– `'g':найденный-фрагмент`,  
– `'g.имя':фрагмент-найденной-групы-с-указанным-именем`.  
Если шаблон неуспешен, то формируется пустой словарь, но обращения к его ключам будут работать:  
    `'top'` и `'btm'` дадут -1, `'g'` и `'g.имя'` дадут пустую строку.  
В словаре сохраняются только именованные re-группы, в том числе с [сахар-именами](#frag-name) фрагментов.  
Если поиск для шаблона выполнялся через XPath, то инфо будут данные **о первом** найденном фрагменте.  

- `note_rt` <a name=note_rt></a>  
    словарь словарей  
Рассчитанные **комментарии** *для первого случая* 
(и первый и все остальные случаи попадают в `usages`).  
Ключи либо `_позиция`, если `note` был задан списком, либо ключи от `note`.  

- `usages` <a name=usages></a>  
    список словарей  
Список всех успешных **применений**, содержащий словари с ключами `'patten_rt'` и `'note_rt'`.  
Набор `usages` не пуст, если было хоть одно успешное применение.  
В этом случае в  
    `usages.0.patten_rt` и `patten_rt` совпадают,  
    `usages.0.note_rt` и `note_rt` совпадают.  

**Модификаторы значений**  

**Подстановки** <a name=subs-mod></a>  
Любое значение (в том числе из списка/словаря) у обязательных/ожидаемых ключей (кроме `formula` и `position`) может 
начинаться с модификаторов  
- `+t:`  
Нужны подстановки вида `{{имя}}`, где "имя" указывает на контектную переменную.  
- `+t{{{}}}:`  
Нужны подстановки вида `{{{имя}}}`.  
- `+te:`  
После подстановок вида `{{имя}}` требуется `eval()`.  
- `+te<<>>:`  
После подстановок вида `<<имя>>` требуется `eval()`.  

Между `+t`/`+te` и `:` могут указываться явные "парные скобки" для выделения имени подставляемого значения.  
Умолчательные "парные скобки" - `{{}}`.  
Пример.  
```python
dict(...,patten='lala',name='nm',...),                  # ищем lala
dict(...,patten='+t:def {{nm.patten}}{{nm.patten}}(',...),  # ищем lalalala в питоне
dict(...,patten='+t<<>>:<br>{{it}} <<nm.patten>> ',...),  # ищем lala в шаблоне
dict(...,patten='+te:"{{nm.patten}}"[:2]',...),           # ищем la
```
  
Для значений у `formula` и `position` эти модификаторы избыточны, так как eval применятся всегда и 
необходимости менять `{{}}` нет.  


**Локализации** <a name=pttn_ast></a>  
Значения из `patten` могут содержать указания на анализ локализации в AST-дереве.   
Для этого они должны начинаться с модификатора:  
    `'+ast:'`  
Тогда в rt-следе для этого значения появится новый ключ  
    `'ast':'локализация'`  
с одним из значений  
    `''` - нет однозначной локализации,  
    `'str'` - фрагмент локализован внутри строкового литерала,  
    `'com'` - фрагмент локализован внутри комментария,  
    `'doc'` - фрагмент локализован внутри док-строки.  
  
Значения из `patten` могут содержать конкретные ограничения на локализацию в AST-дереве.   
Для этого они должны начинаться с одного из модификаторов:  
    `'+ast-in-str:'` - весь найденный фрагмент должен находиться внутри строкового литерала.  
    `'+ast-in-com:'` - весь найденный фрагмент должен находиться внутри комментария.  
    `'+ast-in-doc:'` - весь найденный фрагмент должен находиться внутри док-строки.  
При этом в rt-след всегда добавляется ключ `'ast':'локализация'` 
и умолчательная формула `formula` дополняется его анализом.  
  
Модификаторы локализаций размещаются раньше модификаторов подстановок.  
  
Примеры.  
- Поиск `om` только в виде `par='home'`, но не в виде `home='par'`.  
   ```python
   dict(...,patten='+ast-in-str:om',...),
   ```
- Поиск `om` только внутри комментариев и док-строк.  
   ```python
   dict(...,patten='+ast:om',formula='"{{patten_rt.ast}}" in "com doc"',...),
   ```


## Структура файла знаний с АР-словарями <a name=rv-file></a>  
Файл должен содержать один глобальный словарь вида  
```python
{
   'defaults': {
      'ключ-АР-словаря': 'значение',
      'ключ-АР-словаря': 'значение',
   },
   'регулярка-на-путь-внутри-zip-к-файлу-исходника': [
      АР-словари
   ],
   'регулярка-на-путь-внутри-zip-к-файлу-исходника': [
      АР-словари
   ],
}
```

- Часть `defaults:{}` необязательная.  
Внутри могут указываться любые [обязательные](#need-keys) и [ожидаемые](#waited-keys) ключи АР-словаря, 
в том числе, неописанные в этом доке.  
Всем указанным тут ключам во всех АР-словарях **этого файла** будут назначены указанные значения, 
**если** ключа в АР-словаре нет.

   Примеры.  
   - Можно инвертировать размещения сахаров и регулярок в [изоляторах](#do-sugar) `«...»` 
   через `'wait_re':'T'`.  
   - Можно всем комментариям один раз задать уровень **Надо исправить** через `'level':'E'`, 
   а для некоторых потом явно указывать другие уровни.  
   - Удобно для разных файлов назначить разные "подписи АР" через `end_sign`.  
   Тогда будет видно "из какого файла" АР брал комментарий. 
   - Можно поменять умолчательное место для вставки комментария:  
       с последней найденной строки  
       на первую,  
   указав формулу через `position`.  

- Интерференция регулярок на пути внутри zip.  
   Будут применяться все АР-словари:    
   - Одна регулярка может отбирать несколько путей для исходников.   
   - Один путь к исходнику может подходить нескольким регуляркам.  
   
   Гарантируется, что применения будут в порядке, указанном в файле сверху-вниз.  


## Сборка знаний для одной домашки <a name=build></a>  
1. Внутри zip для одного типа домашек файлы, которые нужно обрабатывать, оказываются в разных папках.  
Это происходит из-за свободы на стороне студентов - они вольны именовать/выбирать ветку в репо 
или даже сдавать вообще самостоятельно собранным архивом.  
Кроме того, общие файлы у серии домашек (Блог-1/2/3, ДРФ-1/2, Фаст-1/2) оказываются размещены 
в разных корневых папках, так как меняется репо.
1. Знания для одного типа домашек почти всегда размещены в нескольких файлах.  
Например, выгодно держать претензии в языку отдельно и включать во все ревью.  
Кроме того, выгодно применять знания от предыдущей домашки из серии.

Поэтому сборка знаний для одной домашки указывает на
– все ожидаемые корневые папки в zip,
– все участвующие в обработках файлы знаний.
АР выполняет попытки применить каждый файл знаний к каждой из корневых папок.

**Оформление**  
В [настройках](#opts) АР за эту сборку отвечает ключ `build_skills` из `opts`:  
```python
opts = dcta(
    build_skills=dcta(
        ключ-домашки=dcta(
            main_dirs_in_zip=[перечисление-ожидаемых-папок],
            skills=[перечисление-нужных-файлов-знаний],
        ),
    ),
)
```
Замечания

1. Ключи домашек задаются в других частях настройки.
1. Ожидаемую в zip папку можно указать явно через опцию запуска `-hd`/`--hw_dir`.  
Тогда список для `main_dirs_in_zip` будет заполнен только этим значением.
1. Файлы в списке по `skills` указываются по абсолютным либо по относительным путям.  

Пример.  
```python
opts = dcta(
    build_skills=dcta(
        bot=dcta(
            main_dirs_in_zip=['homework_bot-master', 'bot-master', ],
            skills=[
                'skills/_bs0_skills2.py',
                'skills/bot_skills2.py',
            ],
        ),
    ),
)
```


## Слияния комментариев от нескольких АР-словарей <a name=merge></a>  
Если к одной строке исходника АР нашел несколько вариантов комментариев, 
то умолчательный алгоритм их смешивания такой:

- Общий уровень комментария задается  
   - как **Отлично**, если такой есть среди вариантов,  
   - иначе как **Надо исправить**, если такой есть среди вариантов.  
- Сначала размещаются варианты с выбранным общим уровнем.  
- За ними размещаются варианты с одинаковыми уровнями: от **Можно лучше** к **Надо исправить**.  
- Если вариантов с общим уровнем несколько, они оформляются a-la "нумерованным" списком:  
   - добавляется разделяющая пустая строка,  
   - добавляется в начало комментария `(N) `, где N его номер в группе с одинаковым уровнем.  

Пример 1.  
Есть набор для комментирования:  
    F, 'false 1'  
    F, 'false 2'  
    G, 'good'  
    E, 'error'  
Тогда комментарий получится такой
```
   good
   
   **Можно лучше**
   (1) false 1
   
   (2) false 2
   
   **Надо исправить**
   error
   
      Отлично
```
Пример 2.  
Есть набор для комментирования:  
    F, 'false 1'  
    E, 'error 1'  
    E, 'error 2'  
Тогда комментарий получится такой
```
   (1) error 1
   
   (2) error 2
   
   **Можно лучше**
   false 1
   
      Надо исправить
```

## Сахара  

### Порядок применения <a name=do-sugar></a>  
- Выделяются сахарные части.  
Они могут быть вне (умолчание) или внутри изоляторов `«...»` в зависимости от `wait_re`.  
- Для каждой сахарной части  
   - Экранируются все знаки натур-регулярок.  
   - В цикле пока происходит хоть одна замена:  
      - Выполняются подмены всех свободных сахаров.  
      - Выполняются подмены всех зашитых сахаров.  

Цикл по заменам означает, что в подменяемой части могут оказываться 
новые сахара - как свободные, так и зашитые.

### Зашитые (неподменяемые!) сахара <a name=in-sugar></a>
- `«шаблон»` <a name=isolator></a>  
**Изолятор**  
В зависимости от значения ключа `wait_re` внутри "лапок" может быть  
    питон-регулярка (если `wait_re` пустой),  
    сахарная разметка (при непустом `wait_re`).  
Изоляторы не могут быть вложенными, но могут появляться при замене свободных сахаров.

- `↓1` ... `↓23` ... <a name=row-num></a>  
`<~ROW>1` ... `<~ROW>23` ...  
**Номера найденных строк**  
Запоминание номера строки, в которой находится такой знак.  
Эти номера можно будет вставлять в комментарии - там они будут доступны под похожими обозначениями  
    `↓1↓` ... `↓23↓`  
    `<~ROW>1<~ROW>`  ... `<~ROW>23<~ROW>`  
Если поисковых шаблонов несколько, то имена для вставок могут содержать явные указания  
    `↓1↓` - от первого элемента (из списка или словаря) `patten`.  
    `↓_0.1↓` - от первого элемента, если `patten` задан списком.  
    `↓имя.1↓` - от элемента `patten` с ключом `имя`.  

- `≤имя≡подшаблон≥` <a name=frag-name></a>  
`<~GRP_NM>имя<~GRP_OP>подшаблон<~GRP_CL>`  
**Имя захваченного подфрагмента**  
Назначение имени для найденного подфрагмента.
Назначенное имя можно будет применять в через `patten_rt.g.имя` в ключах АР-словаря. 
Например, опираться на него в логике или вставлять целиком в конечный комментарий.

Применяются такие регулярные выражения

| Сахар         | Применение в заменах          | Комментарий  |
| --            | --                            | --           |
| `↓1`          | `↓(\d+)` заменяется на `(?P<p\1>(?<!↓))` | Не будет захваченных символов | 
| `≤name≡...≥`  | заменяется на `(?P<name>...)` |              | 

### Плагинные штатные сахара <a name=plug-sugar></a>
- `◊` <a name=same-gap></a>  
`<~GAP>`  
**На том же уровне отступа**  
Фрагмент из нескольких строк (м.б. 0) с такими же (не меньше) сдвигами до начала текста.  

- `!<так¦и так¦и эдак>!`  
`!<так<~VAR>и так<~VAR>и эдак>!`  
**Варианты фрагментов** <a name=vars></a>  
Указываются варианты разметки.  
Ограничение: внутри вариантов не должно быть `!<` `¦` `>!`.  

- `╣фраза╣` <a name=no-next-frag></a>  
`<~NO_AFTER>фраза<~NO_AFTER>`  
**Лишний текст ПОСЛЕ чего-то**  
Фразы не должно быть *за* очередным подходящим символом.  
- `╠фраза╠` <a name=no-prev-frag></a>  
`<~NO_BEFORE>фраза<~NO_BEFORE>`  
**Лишний текст ПЕРЕД чем-то**  
Фразы не должно быть *перед* очередным подходящим символом.  

- `‡` <a name=strap></a>  
`<~TIE>`  
**Стяжка**  
Минимальный заполняющий текст (возможно пустой), в том числе, содержащий концы строк.  
- `(‡)` `[‡]` `{‡}` <a name=bracks></a>  
`(<~TIE>)` `[<~TIE>]` `{<~TIE>}`  
**Фрагмент в парных скобках**  
От открывающей до ее *парной* закрывающей.  

Применяются такие регулярные выражения

| Сахар         | Регулярка или применение в заменах | Комментарий |
| --            | --                   | -- |
| `‡`           | `(?s:.*?)`           | Общий знак `‡` тут и ниже |
| `(‡)`         | `\([^\(\)]*?(?:\([^\(\)]*?(?:\([^\(\)]*?\)[^\(\)]*?)*?\)[^\(\)]*?)*?\)` | Глубина вложенности < 3|
| `[‡]`         | `\[[^\[\]]*?(?:\[[^\[\]]*?(?:\[[^\[\]]*?\][^\[\]]*?)*?\][^\[\]]*?)*?\]` | Глубина вложенности < 3|
| `{‡}`         | `\{[^\{\}]*?(?:\{[^\{\}]*?(?:\{[^\{\}]*?\}[^\{\}]*?)*?\}[^\{\}]*?)*?\}` | Глубина вложенности < 3|
| `◊`           | `\n( *)◊` заменяется на `(\n\\1.*)*` |  |
| `!<` `¦` `>!` | `!<([^¦]+)¦([^>!]+)>!` заменяется на `((\\1)\>(\\2))` (остальные аналогично) | Ожидаются < 10 вариантов |
| `╣...╣`       |  заменяется на `(?!...)`| негативное заглядывание ВПЕРЕД |
| `╠...╠`       | заменяется на `(?<!...)`| негативное заглядывание НАЗАД |


### Свободные (подменяемые!) сахара <a name=free-sugar></a>
Умолчательный набор указывается в `autorv2_free_sugars.py`.  
Там же можно удалять, подменять значения или добавлять свои сахара.  
  
Умолчательный набор  

- `‡‡` `<~ID0>` - **часть идентификатора** <a name=free_id></a>  
Текст (возможно пустой) из букв/цифр/_/точки.  
- `■` `<~FILLER>` - **обязательный заполнитель** <a name=free_1_fill></a>  
Любой непустой текст в пределах строки.  
- `□` `<~FILLER0>` - **заполнитель** <a name=free_0_fill></a>  
Любой текст в пределах строки.  
- `○` `<~BLANKS0>` - **пробельные символы** <a name=free_0_blanks></a>  
Несколько пробелов/табов/EOL (может быть 0).  
- `▫` `<~SPACES0>` - **пробелы** <a name=free_0_spaces></a>  
Несколько пробелов (может быть 0).  
- `▪` `<~BLANKS>` - **обязательные пробельные символы** <a name=free_1_blanks></a>  
Несколько пробелов/табов/EOL.  
- `†` `<~QUOTE>` - **кавычка** <a name=free_quote></a>  
Либо `'`, либо `"`.  

Применяются такие регулярные выражения  

| Символ        | Регулярка  | Комментарий |
| --            | --         | -- |
| `‡‡`          | `[\w\.]*`  | Может быть другой знак |
| `†`           | `[\'\"]`   | |
| `□`           | `.*`       | Мнемоника: пустой символ = "от 0"|
| `■` `▬`       | `.+`       | Мнемоника: непустой символ = "от 1"|
| `○`           | `\s*`      | Мнемоника: пустой символ = "от 0"|
| `▪` `¶±`      | `\s+`      | Мнемоника: непустой символ = "от 1"|
| `▫` `…`       | ` *`       | Мнемоника: пустой символ = "от 0"|


## Порядок обработки и контекстные переменные <a name=actions></a>  


### Порядок обработок <a name=order></a>  
1. Каждый исходный файл из zip обрабатывается назависимо.  
В частности, нет возможности предсказывать какой их двух файлов будет обработан первым.  
1. Порядок применения АР-словарей для одного исходного файла жесткий.  
   - Гарантируется, что АР-словари внутри одного файла знаний будут обрабатываться сверху вниз.  
   - Порядок применения разных файлов знаний фиксирован в [сборке](#build).  
1. АР-словари могут опираться на результаты применения предыдущих АР-словарей, если у них задан [ключ](#name) `name`.  

### Контекстные переменные <a name=context></a>  
Подстановка `{{ЛюБоЕиМя}}` никогда не дает сбоя, если в контексте нет такой переменной.  
Если такая переменная может быть в контексте, например, это ключ АР-словаря, то будет подставляться умолчание.  
В остальных случаях будет подставляться пустая строка.

**Глобальные контекстные переменные** <a name=global-context></a>  
- `{{HW_ZIP_PATH}}` - **полный путь** к исходному zip.
- `{{HW_ZIP_FN}}` - **имя файла** без расширения от zip.
- `{{HW_ITER}}` - **номер итерации** (добавит [Монитор](#monitor), если он вызывает АР).
- От [настроек](#opts) (в том числе от опций запуска) могут поступать дополнительные глобалы.

**Внутренние переменные АР-словарей** <a name=dict-context></a>  
- Внутри одного АР-словаря для `formula`, `position` и остальных значений с [подстановками](#subs-mod) доступны все [ключи](#rv-dict), как контекстные переменные с такими же именами:
   - `{{level}}`, `{{patten}}`, `{{note}}` и т.д., в том числе [rt-следы](#rt-keys)  
   `{{patten_rt}}`, `{{note_rt}}`, `{{usages}}`.
   - Если значение список, то доступ по именам `{{patten._0}}`, `{{patten._1}}` и т.д.  
   При этом совпадают `{{patten}}` и `{{patten._0}}`.
   - Если значение словарь, то доступ по его ключам `{{patten.ключ}}`, `{{patten.еще}}` и т.д.  
   При этом совпадают `{{patten}}` и `{{patten.первый-ключ}}`.
- От предыдущего (см выше) АР-словаря с заданым ключом `name='имя'` доступны все эти же данные с префиксом `имя.`  
   - `{{имя.level}}`, `{{имя.patten}}`, `{{имя.note}}` и т.д.

## Система настроек. Конфиг-файлы и опции запуска <a name=opts></a>  
(*ДОКУМЕНТАЦИЯ В РАЗРАБОТКЕ*)
- Код имеет умолчательные настройки, которые могут быть изменены в любой части через внешний json.
- Каждый из символов в спец.разметке может быть заменен на любую строку 
(но не всякая строках, конечно, уместна, так как поиски будут вестись через регулярки).
- С каждым из файлов в архиве может быть связан произвольный файл (или несколько) с наборами АР-словарей.
- Файлы с наборами АР-словарей могут быть 
  - в виде питон-кода 
  `{'hw02_community-master/yatube/posts/models.py':[dict(...), dict(...),]}`
  - в виде yaml

```yaml
"hw02_community-master/yatube/posts/models.py":
- level: F
  patten: >2-
    group = models.ForeignKey(…
        ◊
        related_name=†!<groups¦group>!†
  note: "Неудачное имя для поля связи."
```

  - в виде json (м.б. кому-то это окажется полезно)



# Дополнительные сервисы


## Монитор для автоматического запуска АР <a name=monitor></a>  
(*ДОКУМЕНТАЦИЯ В РАЗРАБОТКЕ*)
При запуске

    `python autorv2.py -m папка-с-именами-студентов`

происходит зацикливание, при котором АР-Монитор наблюдает за указанной папкой и папками вхоженными в нее.

Отслеживаются:
- Создание новой подпапки (добавился студент).
- Появление в подпапке нового zip (скачана новая домашка).

Действия при появлении нового zip регулируются через настройку `opts.monitor`.

Умолчательный набор действий зашит в код АР. Он может включать:
- Распаковку zip-а.
- Переименование папки с домашкой, чтобы итерации различать.
- Запуск АР для создания нового zip-а.
- Запуск сравнивающей две папки утилиты (типа WinMerge), 
если есть папка с предыдущей итерацией (в том числе из предыдущего ДЗ в цепочке).


## Демонстрация XML для кода из произвольного файла <a name=py2xml></a>  
При запуске

    `python autorv2.py -ax путь-файла.py`

будет создан файл `путь-файла.py.xml`, содержащий XML-дерево построенное из AST-дерева этого кода.


## Демонстрация окончательного вида одного шаблона - подмены всех сахаров
(*ДОКУМЕНТАЦИЯ В РАЗРАБОТКЕ*)
При запуске

    `python autorv2.py -ds путь-файла-знаний::путь-по-знаниям`

из json-данных в указанном файле будет извлечено значение и после замены сахара на регулярки выдано 
в соседний файл

    `путь-файла-знаний.desugar_ГГ-ММ-ДД_ЧЧ-ММ-СС.py`

Путь внутри json записывается с разделителем `>`.  
Спуск в словаре выглядит так  
    `путь-до-словаря>ключ`  
Спуск в списке выглядит так  
    `путь-до-списка>номер-позиции`  

Пример. В знаниях к ДЗ-2 `hw02_skills.py` есть 
```python
'posts/models.py':[
dict(level='G',
    formula='ITER < 2 and m_0',
    patten='''
    group = models.ForeignKey(‡
        on_delete=models.SET_NULL''',
    note='''Удачно.''',
),
dict(level='G',
    patten='''
    group = models.ForeignKey(‡
        related_name=†posts†''',
    note='''Правильно!''',
),

```
После запуска  
    `python autorv.py -ds "path/hw02_skills.py::posts/models.py>1>ptth"`  
появится файл  
    `path/hw02_skills.py.desugar_23-01-14_01-27-07.py`  
с готовой для тестирования регуляркой. Содержимое файла
```
import re

# Регулярка c сахаром
patten = r"""{patten}"""

# Регулярка без сахара
patten = r"""{dspatten}"""

# Задайте тестируемый текст из ДЗ
src = """ """ 
#src = open(r'путь к исходнику в ДЗ', encoding='utf8').read()

# Запуск теста
mt  = re.search(patten, src)
if not mt:return print('fail')
print(mt.groupdict())
```

### Рекомендуемый способ применения
Чтобы не заморачиваться с расчетом пути до нужного patten в полном json-дереве,  
можно завести один пи-исходник `ds.py` с тривиальным наполненем  
    ["""шаблон"""]  
копировать в него нужный для отладки patten и запускать конвертацию всегда одинаково  
    `python autorv.py -ds ds.py::0`




# Брифы


## AST-дерево и его XML-представление <a name=ast_xml_brief></a>  
[Оф-док](https://docs.python.org/3/library/ast.html)
1. Структура дерева
    - Корнем дерева всегда будет узел типа `Module`.
    - Кроме модуля **крупными ветками** дерева станут классы и функции/методы.
    - Крупные ветки могут содержать список из узлов  
       - `Import`/`ImportFrom`
       - `AnnAssign`/`Assign` - присвоение (хинтовой) переменной(ым)
       - `AugAssign` - присвоение с операцией над переменной
       - `Raise`/`Assert`/`Pass`/`Break`/`Continue`/`Return`/`Yield`/`YieldFrom`
       - `If`/`For`/`While`/`Try`/`With`/`Match`
       - `FunctionDef`/`ClassDef`
    - `FunctionDef` содержит 
       - `decorator_list` список из `Name`
       - `name` обязательный текстовый атрибут
       - `args` параметры в виде класса `arguments` с элементами `args` и `kwarg`
       - `body` список узов для крупного узла.
    - `ClassDef` содержит 
       - `decorator_list` список из `Name`
       - `name` обязательный текстовый атрибут
       - `bases` список из `Name`
       - `body` список узов для крупного узла.
1. Представления некоторых узлов  

   Литералы  
`123` как `Constant(value=123)`  
`'abc'` как `Constant(value='abc')`  

   Составные примитивы  
`[123,'abc']` как `List(elts=[Constant(value=123), Constant(value='abc')])`  
`{'abc':123}` как `Dict(keys=[Constant(value='abc')], values=[Constant(value=123)])`  
  
   Генераторный список `[x for x in ns]` как  
   ```python
   ListComp(
     elt=Name(id='x'),
     generators=[comprehension(target=Name(id='x'), iter=Name(id='ns'))])
   ```
   
   Генераторный словарь `{x: x**2 for x in ns}` как  
   ```python
   DictComp(
     key=Name(id='x'),
     value=BinOp(left=Name(id='x'), op=Pow(), right=Constant(value=2)),
     generators=[comprehension(target=Name(id='x'), iter=Name(id='ns'))]))
   ```

   Объявление функции `def func(a, b=c, *d, **e):pass` как  
   ```python
   FunctionDef(name='func',
     args=arguments(
       args=[arg(arg='a'), arg(arg='b')],
       defaults=[Name(id='c')]),
       vararg=arg(arg='d'),
       kwarg=arg(arg='e'),
     body=[Pass()],
     decorator_list=[])
   ```

   Вызов функции `func(a, b=c, *d, **e)` как  
   ```python
   Call(func=Name(id='func'), 
        args=[Name(id='a'), Starred(value=Name(id='d'))], 
        keywords=[keyword(arg='b',value=Name(id='c')), keyword(value=Name(id='e'))])
   ```

   Объявление класса `class Foo(B1, B2):pass`
   ```python
   ClassDef(
     name='Foo',
     bases=[Name(id='B1', ctx=Load()), Name(id='B2', ctx=Load())],
     body=[
       Pass()],
     decorator_list=[])],
   ```

1. Замечания
   - В дереве не сохраняются комментарии!
   - У узлов модуль/класс/функция можно узнать док-строку.
   - У AST-узла через атрибуты  
       `lineno`, `col_offset`, `end_lineno`, `end_col_offset`  
можно узнать его локализацию внутри исходного текста.  
   - Увидеть AST-дерево для произвольного Питон-кода можно через  
       `import ast;print(ast.dump(ast.parse(код), indent=2))`

1. XML представления  
Для произвольного Питон-модуля можно увидеть его полный XML через [спец-запуск](#py2xml) АР2.

   Литералы  
`123` как  
   ```xml
   <Constant type="int" value="123"/>`
   ```
   `'abc'` как  
   ```xml
   <Constant type="str" value="123"/>`
   ```

   Составные примитивы  
`[123,'abc']` как  
   ```xml
   <List><elts>
     <Constant type="int" value="123"/>
     <Constant type="str" value="abc"/>
   </elts></List>`
   ```

   `{'abc':123}` как  
   ```xml
   <Dict>
     <keys><Constant type="str" value="abc"/></keys>
     <values><Constant type="int" value="123"/></values>
   </Dict>`
   ```

   Генераторый список `[x for x in ns]` как  
   ```xml
   <ListComp>
     <elt><Name id="x"/></elt>
     <generators>
       <comprehension>
         <target><Name id="x"/></target>
         <iter><Name id="ns"/></iter>
         <ifs/>
       </comprehension>
     </generators>
   </ListComp>
   ```

   Генераторный словарь `{x: x**2 for x in ns}` как  
   ```xml
   <DictComp>
     <key><Name id="x"/></key>
     <value>
       <BinOp>
         <left><Name id="x"/></left>
         <op><Pow/></op>
         <right><Constant type="int" value="2"/></right>
       </BinOp>
     </value>
     <generators>
       <comprehension>
         <target><Name id="x"/></target>
         <iter><Name id="ns"/></iter>
         <ifs/>
       </comprehension>
     </generators>
   </DictComp>
   ```

   Объявление функции `def func(a, b=c, *d, **e):pass` как  
   ```xml
   <FunctionDef name="func">
     <args>
       <arguments>
         <args><arg arg="a"/><arg arg="b"/></args>
         <defaults><Name id="c"></Name></defaults>
         <vararg><arg arg="d"/></vararg>
         <kwarg><arg arg="e"/></kwarg>
       </arguments>
     </args>
     <body><Pass/></body>
   </FunctionDef>
   ```

   Вызов функции `func(a, b=c, *d, **e)` как  
   ```xml
   <Call>
     <func><Name type="str" id="func"></Name></func>
     <args>
       <Name type="str" id="a"/>
       <Starred ><value><Name type="str" id="d"/></value></Starred>
     </args>
     <keywords>
       <keyword type="str" arg="b">
         <value><Name type="str" id="c"/></value>
       </keyword>
       <keyword><value><Name type="str" id="e"/></value></keyword>
     </keywords>
   </Call>
   ```

   Объявление класса `class Foo(B1, B2):pass`  
   ```xml
   <ClassDef name="Foo">
     <bases><Name id="B1"/><Name id="B2"/></bases>
     <body><Pass/></body>
     <decorator_list/>
   </ClassDef>
   ```


## Про XPath-язык <a name=xpath_brief></a>  
[Оф-док](https://docs.python.org/3/library/xml.etree.elementtree.html#supported-xpath-syntax)
1. Общий вид XPath-запроса на излечение узлов из XML  
    `тег/*/*[условие]//тег[@атрибут]/тег[../тег[@атрибут=123]]//тег[@атрибут!='y']]/тег[2]/*[2]/*[last()]`  
где  
   - `/*` все вложенные узлы,
   - `[условие]` может рекурсивно содержать извлечения узлов с условиями,
   - `//тег` спуск на произвольную глубину до всех `тег`ов,
   - `тег[@атрибут]` все `тег`и с таким `атрибут`ом (любое его значение),
   - `тег[@атрибут=123]` все `тег`и с таким значением `атрибут`а,
   - `тег[@атрибут!='y']` все `тег`и с другим значением `атрибут`а,
   - `тег/../брат` соседний `брат`, то есть дочерний у предка `тег`,
   - `/тег[2]` **второй** (не третий) из `тег`ов,
   - `/*[2]` **второй** из всех,
   - `/*[last()]` последний из всех.
1. В этом языке нет логических операторов.  
Но можно трюком получить AND, если несколько раз заходить в уникальный узел через родителя.  
Пример. Поиск  
    `тег[@атрибут1]/../тег[@атрибут2=2]/../тег[@атрибут3!='y']`  
найдет `тег`, если у него выполнятся все три условия на аттрибуты.
1. Примеры для поисков от корня AST-XML-дерева  
   - `//ClassDef[@name='Post']//ClassDef[@name='Meta']`  
   Извлечение класса Post.Meta.
   - `//ClassDef[@name='Post']//Assign[targets/Name[@id='title]]//Call//keyword[@arg='verbose_name']`  
   Извлечение для класса `Post` из поля `title` параметра `verbose_name`.  
   Логика поиска:  
   – Из всех классов нужен с имеем `Post`.  
   – Из всех присвоений внутри класса (=объявлений полей) нужно с левой частью `title`.  
   – В провой части присвоения внутри вызова (конструктор) нужен ключевой параметр `verbose_name`.  
   При записи в виде  
       `//*[@name='Post']//*[targets/Name[@id='title]]//keyword[@arg='verbose_name']`  
   получается такой же поиск, лишь менее эффективный.



# Известные проблемы
- Ревизор глотает начальные пробелы в комментах.  
Поэтому АР меняет левый пробел на символ `·`.  
В результате примеры кодов/разметки в комментах оказываются некорректными.  
Ждем исправления Ревизора.



# (ToDo) В планах
- Обмен вычисленными значениями между найденными случаями.
- Добавить элементы AST-флагов в знания: указывать "в комментарии" или "внутри строкового литерала".
- Добавить "человеко-пальце-любивые" синонимы для сахаров.
- Добавить "внятные" синонимы для ключей АР-словаря.
- Добавить примеры поисков регулярками и их записи сахарами.



# Зависимости и заимствования
- [lxml](https://lxml.de/) для работы с XML.
- Конвертация AST-дерева в XML из [pyastgrep](https://github.com/spookylukey/pyastgrep)
- Регулярка для поиска парной скобки от [codengineering.ru](https://codengineering.ru/q/kak-obrabatyvat-vlozhennye-skobki-s-pomoschyu-regulyarnyh-vyrazheniy-37503)



# История обновлений
## 2.0.100 29feb24
- [+] Старт разработки
