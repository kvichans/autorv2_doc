# Цель
Консольная утилита, преобразующая архив с ДЗ в новый архив, 
который Ревизор готов принять и перенести из него комментарии в исходные файлы домашки.



# Способ применения
Минимальный полезный запуск (требуется Питон 3.10+)
```
python autorv2.py путь-к-домашке.zip
```
создаст (перезапишет!) файл `путь-к-домашке(fN_!F_+G_-E).zip`, который можно передать Ревизору.  
Вместо `N`, `F`, `G`, `E` будут подставлены числа, отражающие результат работы:  
    `N` - число файлов, в которые попали комменты,  
    `F` - число неточностей (**Можно лучше**),  
    `G` - число удач (**Отлично**),  
    `E` - число ошибок (**Надо исправить**).

Полезные разделы:
- [Установка](#opts_install)  
- [Минимальная шпаргалка новичка](#min_brief)  
- [Готовые решения](#ready_cases)  
- [АР-словарь](#rv-dict)  


# Основные идеи


## (1) Ревьювер сохраняет свои навыки в "приватных знаниях"

1. Настройки знаний размещаются в **приватных** json-подобных файлах.  
Для одной домашки собираются знания из нескольких файлов.  
Например, можно выносить претензии к нарушениям языка/РЕР8 в файл, который применять для всех домашек.  
Например, можно для серии домашек подхватывать файл от предыдущей домашки.  
2. Порядок сборки файлов знаний указывается в **публичных** или **приватных** настройках АР.  
Такие настройки (точнее их умолчательный вариант) публикуются вместе с исполняемым кодом.


## (2) Способы поиска
У ревьювера есть выбор для организации поиска мест, требующих комментирования.
Он может опираться на поиск регулярками в тексте модуля и/или анализировать элементы AST-дерева, 
то есть на наличие и свойства описанных объектов.

1. Можно писать только Питон-регулярки. <details><summary>За-и-против</summary>
    (+) Для "прокачанных" не потребуется переучиваться.  
    (+) Не потребуются символы, которых нет на клавиатуре.  
    (-) Будут появляться громоздкие и/или малопонятные конкструкции.  
    Например, регулярка, захватывающая до парной фигурной скобки,   
    `\{[^\{\}]*?(?:\{[^\{\}]*?(?:\{[^\{\}]*?\}[^\{\}]*?)*?\}[^\{\}]*?)*?\}`.  
    (-) Обязательно выполнять экранирование точек, скобок, обратных слешей и прочих re-символов,  
    если они есть в искомом фрагменте.  
    </details>
1. Чтобы избегать громоздкости регулярок и экранирований, АР предлагает применять сахара.  
    **Сахар - часть поисковой разметки, которая позже станет регуляркой.**  
Ближайший аналог - макрос в С/С++.  
Сахара специально записываются символами, которые точно не встречаются в re-языке 
(и еще вряд ли встретятся в исходниках). <details><summary>За-и-против</summary>  
    (+) Поисковый шаблон компактный, а значит более понятный.  
    (+) Доступны доп-сервисы от АР (например, запоминание номеров строк).  
    (-) Смыслы сахар-знаков неочевидны.  
    (-) Придется копировать знаки из доки или из предыдущих применений.  
    </details>

   На месте сахара может появится примитивная регулярка. Например,  
    `■` подменяется на `.+` и позволяет захватывать любые символы в текущей строке.  
Сахар может заменяться на громоздкое re-выражение. Например,  
    `{‡}` дает захват до парной фигурной скобки (см выше).  
Но сахарые подмены могут в АР достигать и более сложных целей.  
Они могут захватывать окружающие символы, чтобы конечная регулярка их учитывала:  
    `◊` позволяет построить поиск нескольких подряд строк с таким же отступом, как перед этим знаком.  
    `...╣фраза╣`/`╠фраза╠...`/`...╔фраза╗...` позволяет построить поиск фрагмента 
без указанной фразы после/перед/между `...`.  
Есть еще более продвинутые сахара.  
    `↓1` позволяет АР запоминать номер строки исходника, где встретился такой сахар.  
    Позже этот номер можно будет вставить в комментарий и/или использовать в логике.  

   Вставить сахар в шаблон можно несколькими способами:
   - Через недоступный с клавиатуры **сахар-символ**, такой как `■`.  
   - Через указание **Юникод-имени** внутри штатной конкструкции: `'\N{BLACK SQUARE}'`.  
У *всех* символов есть такие имена - их можно узнать через `unicodedata.name('■')`.  
   - Через указания **АР-имени** внутри конструкции `<~FILLER>`.  
У всех сахаров (их частей) есть такие имена.  

   Чтобы совместить "плюсы" от всех за-и-против, АР предоставляет возможность внутри 
одного поискового шаблона иметь зоны "чистых регулярок" и зоны "сахарной разметки".  
Одна из зон будет считаться главной, а части второй будут размещаться в **изоляторах**:  
    либо через заключение в лапки `«...»`,  
    либо через в более громоздкие, но более "печатные" `<!<...>!>`.  
Какая зон попадет в изолятор, настраивается:  
   - По умолчанию АР считает весь шаблон сахарным, а внутри изоляторов видит регулярки.  
   - Настройкой можно переключить АР на ожидание регулярок вне изоляторов и сахаров внутри изоляторов.  
   - Такую настройку зон можно задать для одного/группы/всех поисков.  
1. AST-дерево и шаблоны поиска его узлов.  
Можно писать XPath-выражения на поиск элементов в AST-дереве, преобразованном в XML. <details><summary>За-и-против</summary>
    (+) Работа с понятыми объектами модуль/класс/функция/параметр/переменная/значение/...  
и их понятными свойствами тип/место-в-исходнике/...  
    (+) Работа с могучим XPath-языком для указания поисков в дереве.  
    (-) Необходимость изучить детали (много их) модуля `ast` (см [ast-бриф](#ast_xml_brief), [Питон↑](https://docs.python.org/3/library/ast.html#module-ast)).  
    (-) Необходимость представлять структуру AST-дерева для ожидаемого кода из домашки.  
    (-) Необходимость изучить XPath-язык (см [XPath-бриф](#xpath-brief), [Питон↑](https://docs.python.org/3/library/xml.etree.elementtree.html#xpath-support), [w3.org↑](https://www.w3.org/TR/1999/REC-xpath-19991116/)).  
    (-) Теряется возможность запоминать промежуточные подфрагменты.  
    </details>

1. Можно дополнять поиски регулярками/сахарами через анализ места найденных ими фрагментов в AST-дереве.  
Например, будет полезно знать, что фрагмен оказался целиком внутри текстового литерала или внутри комментария.  
Еще полезно, например, учесть, что фрагмент оказался внутри подходящего класса/метода/функции.

## (3) Минимальным элементом "знаний" является АР-словарь
Цель такого [АР-словаря](#rv-dict) - указать для одной претензии "что найти" и "как прокомментировать".  

**Пример.**  
Нужно искать в домашке выражения вида  
    `kwargs={'идентификатор': любой-код}`  
При этом запоминать `любой-код` и номер строки, где находится `kwargs`.  
Нужно сформировать комментарий вида  
    `Рекомендую в строке ... заменить kwargs={'id': ...} на args=[...].`  
  
Вот АР-словарь c **сахар-символами**, который может это сделать
```python
dict(
    level='F', 
    pattern='''kwargs↓1={'‡‡': ≤key≡‡≥}''',
    note='Рекомендую в строке {{_.↓1}} заменить `{{hits._.txt}}` на `args=[{{hits._.txt_key}}]`.',
)
```
Тут применены  
    `↓1` - **номер строки** (АР его запомнит).  
    `‡‡` - **идентификатор**, то есть буквы-цифры-_-точки.  
    `≤` `≡` `≥` - **именованная группа**: начало имени, завершение имени и начало поиска, конец поиска.  
    `‡` - **стяжка**, минимальный набор любых символов.  
Конструкция `≤key≡‡≥}` запоминает под именем `key` все что захватит стяжка, то есть до ближайшего `}`.  
  
<details><summary>Этот же АР-словарь c **сахар-именами**</summary>  

Вот как этот же АР-словарь записывается с **сахар-именами**, то есть без спец-знаков:  
    `↓` стал `<~ROW>`,  
    `‡‡` стал `<~ID0>` (0 показывает, что захват может быть пустой),  
    `≤` `≡` `≥` стали `<~GRP_NM>` `<~GRP_OP>` `<~GRP_CL>`,  
    `‡` стал `<~TIE>`.  
```python
dict(
    level='F', 
    pattern='''kwargs<~ROW>1={'<~ID0>': <~GRP_NM>key<~GRP_OP><~TIE><~GRP_CL>}''',
    note='Рекомендую в строке {{_.<~ROW>1}} заменить `{{hits._.txt}}` на `args=[{{hits._.txt_key}}]`.',
)
```
</details>

<details><summary>Этот же АР-словарь **на регулярках**</summary>  

Вот как этот же словарь можно переделать **на регулярки** вместо всех сахаров, 
кроме запоминания номера строки, который помещен в **изолятор** `«↓1»`  
    `‡‡` стал `[\w\.]*`,  
    `≤` `≡` `≥` стали `(?P<` `>` `)`.  
    `‡` стал `(?s:.*?)`,  
```python
dict(wait_re='T',
    level='F', 
    pattern=r'''kwargs«↓1»=\{'[\w\.]*': (?P<key>(?s:.*?))\}''',
    note='Рекомендую в строке {{_.↓1}} заменить `{{hits._.txt}}` на `args=[{{hits._.txt_key}}]`.',
)
```
Кроме замены сахаров потребовались еще доделки:  
    `wait_re='T'` - указание на "сахара будут в изоляторе",  
    добавление модификатора `r'''...'''`,  
    экранирование фигурных скобок.  
</details>

Применение всех трех АР-словарей одинаковое.  
Если в исходнике в строках 123..126 есть код  
```python
123   ... = reverse(
124       'new:edit', 
125       kwargs={'id': post_id}
126   )
```  
то АР **добавит комментарий** к строке 125  
```python
123   ... = reverse(
124       'new:edit', 
125       kwargs={'id': post_id}
      Рекомендую в строке 125 заменить `kwargs={'id': post_id}` на `args=[post_id]`.
         Можно лучше
126   )
```  

Если упростить задачу:  
    Искать в домашке выражения вида  
        `kwargs=`  
    Сформировать комментарий вида  
        `Рекомендую заменить kwargs={...} на args=[...].`  
Тогда вот такой АР-словарь c **XPath-шаблоном** подойдет  
```python
dict(level='F', 
    pattern='''//keyword[@arg="kwargs"]''',
    note='''Рекомендую заменить kwargs={...} на args=[...].''',
)
```  
Тут применены  
    `//keyword` - поиск от корня дерева любого узла с именем `keyword`, то есть параметра функции.  
    Первый символ `/` подсказывает, что это путь по дереву.  
    `[@arg="kwargs"]` - проверка имени у этого параметра, нужен только `kwargs`.  
В результате будут найдены узлы вида  
    `<Call><func><Name id="reverse"></func>...<keyword arg="kwargs">...`  
то есть в текстовом исходнике это было  
    `reverse(..., kwargs=...)`

    
## (4) Порядок применения АР2 руками <a name=hand-use></a>

1. Подготовить хотя бы один файл-знаний.  
АР2 по умолчанию ищет знания в своей подпапке `skills`.  
Например, можно создать файл `skills/skill_of_python.py` с таким наполнением 
(ловим переносы символом `\`, [подробности](#ready_continue) настройки)  
   ```python
   {
     '*.py':[
       dict(level='E', wo_strip='T', repeats='all'
            pattern='\\\n', 
            note=['Так низяяяяя! Заключайте в скобки.','Смотри выше',],
       ),
     ],
   }
   ```
1. Указать в АР2-настройках этот файл для проверяемой домашки.  
Например, если это ДЗ Бот, то внутри файла `autorv2.cfg.py` в ветке `skills` нужно показать созданный файл знаний:  
   ```python
       ...
       skills=dict(
           bot=dict(
               skills=['skills/skill_of_python.py',], # <<<<<<<<<<<<<<<<
           ),
       ),
       ...
   ```
   Этот шаг можно заменить на опцию при вызове - см ниже.
1. В Ревизоре на вкладке Ревью нажать верхнюю кнопку "скачать код" 
![image](https://github.com/kvichans/autorv2_doc/assets/7419630/259e97c9-e698-425a-ad29-284623e34ab4) 
или нижнюю ссылку "Скачать код"  
![image](https://github.com/kvichans/autorv2_doc/assets/7419630/ad444643-544e-46e6-8d74-5cec55a49af1)  
1. Сохранить zip-файл в подходящей папке.  
1. Запустить АР2 в консоли через  
   ```bash
   > python autorv2.py путь-к-домашке.zip
   ```
   Можно вместо правки настроек прямо тут указать файл знаний  
   ```bash
   > python autorv2.py путь-к-домашке.zip -o "skills.bot.skills=['skills/skill_of_python.py']"
   ```
   Рядом с `путь-к-домашке.zip` будет создан файл с комментариями вида `путь-к-домашке(f1_!1_+0_-0).zip`.  
1. В Ревизоре нажать на кнопку  
![image](https://github.com/kvichans/autorv2_doc/assets/7419630/c3a07a28-b649-47c5-812a-2af5c53d7a63)  
и выбрать созданный файл `путь-к-домашке(f1_!1_+0_-0).zip`.


## (5) Порядок применения АР2-Монитора <a name=monitor-use></a>

1. Подготовить файл-знаний `знания.py` (например, как в [ручном запуске](#hand-use)).
1. Указать эти знания в АР2-настройках для каждой конкретной домашки. Например, для Змейки
   ```python
       ...
       skills=dict(
           snk=dict(
               skills=['skills/знания.py',], # <<<<<<<<<<<<<<<<
           ),
       ),
       ...
   ```
1. Один раз запустить Монитор в консоли/демоне/сервисе  
   ```bash
   > python10 autorv2.py -m папка-всех-студентов
   ```
   При доработках в `знания.py` Монитор перезапускать не нужно - он сам подхватит изменения.  
При доработках АР2-настроек перезапуск нужен.
1. Теперь можно сохранять из Ревизора zip-файл с домашкой в  
    `папка-всех-студентов`  
или в  
    `папка-всех-студентов/студент`  
    NB! Монитор не создает подпапку `студент` - это ручная работа для ревьювера.  
Монитор  
    отследит появление zip,  
    запустит АР2.  
Для ревьювера это будет выглядеть так, будто **zip-файл с комментариями появится сам**.  
Останется подхватить его в Ревизоре так же, как при [ручном запуске](#hand-use).  
1. Если Монитор настроен с запуском дифф-тула, то после сохранения zip в папку  
    `папка-всех-студентов/студент`  
Монитор распакует его в новую подпапку - ее имя сформируется из главного ключа и номера итерации.  
Например, для Змейки это будут папки  
    `папка-всех-студентов/студент/snk_1`,  
    `папка-всех-студентов/студент/snk_2` и тд.  
Монитор запустит дифф-тул, чтобы показать разницу последней и предыдущей итераций.

Подробнее см [АР-Монитор](#monitor).

## (6) Приватная адаптация поисков

Ревьювер волен применять АР2 как есть, либо развивать его самостоятельно.  
Кроме файлов знаний с АР-словарями, ревьювер может создавать личные расширения/плагины для АР.  

### Cвои свободные и/или плагинные сахара
Простейший способ адаптировать поиск под свои потребности - добавить **свои сахара**.  

Для этого нужно знать, что сахарные знаки делятся на
- [Зашитые](#in-sugar) в код АР:  
    `«` `»` `↓`.  
Они задействованы в собственных алгоритмах АР.  
- [Плагинные](#plug-sugar), дополняющие код АР:  
    `‡` `(‡)` `[‡]` `{‡}` `╠` `╣` `◊` `►` `▲` `◄` `≤` `≡` `≥`.  
Они задействованы через API для сахаров.  
Их полные реализации находятся в модуле  
    `autorv2_plug_sugars.py`.
- [Свободно](#free-sugar) заменяемые/дополняемые. 
Каждый из них подменяется на фиксированную регулярку.  
В штатный набор входят:  
    `‡‡` `□` `■` `○` `▪` `▫` `†`.  
Такие знаки, их имена и регулярки перечислены в json-подобном файле (фактически в таблице)  
    `autorv2_free_sugars.py`,  
который АР2 подхватывает после запуска.  

Кроме того, нужно учитывать:  
- Замены "свободных" выполняются раньше замен "плагинных", которые - раньше "зашитых".  
- В результате замены "свободных"/"плагинных" могут появиться новые сахара, в том числе зоны изоляции.  
- Подмены будут продолжаться пока в сахарных зонах не кончатся сахара.  

**Пример**.  
Добавление свободного сахара.  
Штатный файл со свободными выглядит так
```python
[
    ...
    ['†'    ,'QUOTE'    ,'[\'"]'],       # Одна из кавычек
]
```
Если его дополнить
```python
[
    ...
    ['†'    ,'QUOTE'    ,'[\'"]'],       # Одна из кавычек
    ['⌂'    ,'HOME'     ,'†«[home]+»†'], # Дом, милый дом!
]
```
то в поисковых шаблонах можно будет через `⌂`/`<~HOME>` искать  
    <кавычка><буквы слова home><кавычка>

**Пример**.  
Добавление плагинного сахара, чтобы искать семь подряд одинаковых фрагментов.  
В файле `autorv2_plug_sugars.py` нужно создать/импортировать класс вида
```python
class SevenCopies(PlugSugar):
    SIGN  = '⅐'
    NAME  = '1_7'
    NAME = NAME_TEMPLATE.format(NAME) # Преобразование в '<~1_7>'
    def replace(self, pttn :str) ->str:
        pttn = pttn.replace(self.NAME, self.SIGN)
        pttn = re.sub(rf'{{self.SIGN}}(.*rf){{self.SIGN}}', '(\1){7}', pttn)
        return pttn
```
Тогда шаблон `'⅐xY⅐'`/`'<~1_7>xY<~1_7>'` найдет в тексте `'abcxYxYxYxYxYxYxYabc'` фразу `YxYxYxYxYxYxY`.
  
### Cвои плагины.
(*ДОКУМЕНТАЦИЯ В РАЗРАБОТКЕ*)


### Форк проекта и наследования классов.
(*ДОКУМЕНТАЦИЯ В РАЗРАБОТКЕ*)  
После форка доступен для модификации умолчательный алгоритм оформлением полного комментария по нескольким подходящим - достаточно подменить вызов функции `simple_render(набор-комментариев)`.  



# Готовые решения<a name=ready_cases></a>  

## Готовые поиски для Змейки
В модуле  
    `skills/snake_demo_skills2.py`  
есть полуфабрикат для ревью Змейки.
Для большинства [чеков](https://www.notion.so/praktikum/1-3-Pygame-adedd1f4fca94ed7b37a4443b7da8409) 
созданы шаблоны поиска.  
Осталось заменить заглушки `низззя!`/`не лучший способ` на содержательные сообщения.  

Например, АР-словарь с заглушкой  
```python
# В пустых методах без тела не нужно писать pass, если есть докстринг
dict(level='E', note='низззя!1',
    pattern='''
    def ‡(self):
        """‡"""
        ◊
        pass
''', 
),
```
нужно самостоятельно заменить на что-то такое
```python
# В пустых методах без тела не нужно писать pass, если есть докстринг
dict(level='E',
    pattern='''
    def ‡(self):
        """‡"""
        ◊
        pass
''', 
    note='''
Лишняя строка. 
Ведь док-строка выше уже создает непустое тело для метода.''',
),
```

В [шпаргалке](#min_brief) есть компактное описание, достаточное для понимания деталей из `snake_demo_skills2.py`.

## Готовые проверки всех питон-кодов
В модуле `skills/base_skills2.py` собраны несколько АР-словарей для базовых проверок всех питон-кодов. 

### Не хватает пустой строки в конце модуля
Применяется прямая (несахарная) регулярка  
    `pattern=r'«\S\Z»'`  
Тут используется `\Z` вместо `$`, так как `\Z` ловит только конец исходника, а `$` ловит еще и конечные `\n`.

### Неуместные одинарные и двойные кавычки внутри одного модуля
Настройка
```python
    formula='SRC_FN not in ['
        '"manage.py"'
    ']',
```
позволяет пропускать анализ внутри штатных модулей. 

Сложность поиска в том, что док-строки должны быть в двойных кавычках, 
а в остальном коде могут применяться как двойные так и одинарные.

Применяется сахарная регулярка  
    `pattern="""►'‡╠"╠"╣"╣▲╠"╠"╣"╣‡'◄"""`  
Ее можно прочитать так  
    Ищутся варианты через `►▲◄`.    
    Либо от одинарной кавычки можно дойти (это `‡`) до изолированной двойной.  
    Либо от изолированной двойной кавычки можно дойти (это `‡`) до одинарной.  
При этом "изолированная двойная" задана через `╠"╠"╣"╣`, то есть ни до ни после нее нет еще такой же.

Такой поиск имеет серьезные недостатки:
- Не пропускаются одинарные кавычки, входящие в английские фразы:  
    `Couldn't import Django`.
- Не пропускаются кавычки, находящиеся внутри текстовых литералов.

### Неуместный символ \ для склеивания строк
Применяется такой АР-словарь
```python
dict(
    wo_strip=True,
    pattern='\\\n',
    note='Низзя!',
),
```
Пояснения.
1. `wo_strip=True` нужен, чтобы АР2 не удалил из шаблона конечный символ `\n`.
1. `pattern='\\\n'` поиск двух символов.


### После док-строки лишний pass
Применяется такой АР-словарь
```python
dict(
    pattern=[
        '''
def ‡‡(‡):
    """‡"""○pass''',
        '''
    def ‡‡(‡):
        """‡"""○pass''',
        '''
class ‡:
    """‡"""○pass''',
    ], 
    note='Низзя!',
),
```
Пояснения.
1. Выполняется поиск хотя бы одного из трех шаблонов `pattern=[..., ..., ...]`.
1. Условие `"""‡"""` ищет *минимальный* произвольный код от тройных кавычек до следующих тройных.
1. Условие `def ‡‡(‡):` ищет идентификатор (это `‡‡`) и любой код внутри *парных* круглых скобок (это `(‡)`).
1. Условие `"""‡"""○pass` ищет док-строку, за которой через произвольный набор пробельных символов (это `○`) находится `pass`.
1. Условие `class ‡:` ищет *минимальный* произвольный код от `class ` до `:`.


## Подсказки решений для типовых ситуаций

<details><summary>Подсказки</summary>

### Нарушение порядка импортов
Поиск случаев, когда импорты установленных либ идут позже импортов из проекта.  

**АР-словарь с сахар-символами**:  
```python
dict(level='E', 
    pattern=[dedent('''\
        from ►.▲post▲blog▲app◄■○
        from ►django▲rest▲flask▲fast◄
    '''),], 
    note='А как же РЕР8? Учили вас, учили...',
),
```
<details><summary>Этот же АР-словарь с сахар-именами</summary>  


```python
dict(level='E', 
    pattern=[dedent('''\
        from <~LF_VAR>.<~VAR>post<~VAR>blog<~VAR>app<~RT_VAR><~FILLER><~BLANKS0>
        from <~LF_VAR>django<~VAR>rest<~VAR>flask<~VAR>fast<~RT_VAR>
    '''),], 
    note='А как же РЕР8? Учили вас, учили...',
),
```

</details>

*Пояснения.*  
- `►.▲post▲blog▲app◄` `<~LF_VAR>.<~VAR>post<~VAR>blog<~VAR>app<~RT_VAR>` - поиск одного из указанных простых фрагментов.  
- `■` `<~FILLER>` - любые символы в пределах этой же строки, то есть окончание импорта.  
- `○` `<~BLANKS0>` - любые пробельные символы, например, пустые разделяющие строки.  

**Реакции**:  
- В каждом модуле один раз указывается на недостаток в импортах.  

### Нарушение 2-сдвигов в шаблонах
(*В разработке*)
### Неуместные print() в рабочих модулях
(*В разработке*)
### Нарушенный порядок поле-Meta-метод в модели
Поиск случаев, когда в классе не выполнена рекомендация размечать в порядке поля-классы-методы.  

**Размещение**: в файле знаний для проверки проектов с моделями  
```python
{
  'defaults': dict(level='E', repeats='all',),
  '.*models.py':[тут],
}
```
**АР-словари с сахар-знаками**:  
```python
dict( 
    pattern=[dedent('''\
        class ■
            ◊
            def ↓2■
            ◊
            class Meta↓1■
    '''),], 
    note=['Не ложьте Мета за методы (см с.{{_.↓2}})!', ' См выше (строка {{_.↓1}}).'],
),
dict( 
    pattern=[dedent('''\
        class ■
            ◊
            class Meta■
            ◊
            ‡‡ = ↓1■
    '''),], 
    note=['Не ложьте Мета перед полями!', ' См выше (строка {{_.↓1}}).'],
),
dict( 
    pattern=[dedent('''\
        class ■
            ◊
            def ↓2■
            ◊
            ‡‡ = ↓1■
    '''),], 
    note=['Не класьте поля за методы (см с.{{_.↓2}})!', ' См выше (строка {{_.↓1}}).'],
),
```

<details><summary>Эти же АР-словари с сахар-именами</summary>  


```python
dict( 
    pattern=[dedent('''\
        class <~FILLER>
            <~GAP>
            def <~ROW>2<~FILLER>
            <~GAP>
            class Meta<~ROW>1<~FILLER>
    '''),], 
    note=['Не ложьте Мета за методы (см с.<~ROW>2<~ROW>)!', ' См выше (строка <~ROW>1<~ROW>).'],
),
dict( 
    pattern=[dedent('''\
        class <~FILLER>
            <~GAP>
            class Meta<~FILLER>
            <~GAP>
            <~ID0> = <~ROW>1<~FILLER>
    '''),], 
    note=['Не ложьте Мета перед полями!', ' См выше (строка <~ROW>1<~ROW>).'],
),
dict( 
    pattern=[dedent('''\
        class <~FILLER>
            <~GAP>
            def <~ROW>2<~FILLER>
            <~GAP>
            <~ID0> = <~ROW>1<~FILLER>
    '''),], 
    note=['Не класьте поля за методы (см с.<~ROW>2<~ROW>)!', ' См выше (строка <~ROW>1<~ROW>).'],
),
```

</details>

*Пояснения.*  
- `'defaults': dict(level='E', repeats='all',)` - общее задание ключей `level` и `repeats` для всех АР-словарей.  
- `■` `<~FILLER>` - любые символы в пределах этой же строки.  
- `◊` `<~GAP>` - любое количество (в тч нулевое) строк с таким же отступом (тут - 4 пробела).  
- `‡‡` `<~ID0>` - идентификатор, т.е. слово из букв-цифр-_-точек. `‡‡ = ` ловит имя поля.  
- `↓1` `<~ROW>1` - запомнить номер строки с первым найденным случаем.  
- `{{_.↓1}}` `{{_.<~ROW>1}}` - вставить номер запомненной строки.  

**Реакции**:  
- В модуле с моделями указывается на все неудачные взаимные размещения полей/Meta/методов.  
- Первый раз подробно. Остальные ссылкой на первый.  

### Не хватает локализации модели
Поиск случаев, когда в `Meta` у модели нет переводов.  
**Логика поисков**  
    Если не найден `verbose_name` внутри `Meta`,  
    но найден сам `Meta` (или хотя бы класс модели), где он должен быть,  
    то нужен комментарий у `Meta` (или у класса модели).  

**Размещение**: в файле знаний для проверки проектов с моделями  
```python
{
  '.*models.py':[тут],
}
```
**Варианты АР-словарей**  
  
**(Вариант 1) XPath**-шаблоны в `pattern` заданы **списком**  
```python
dict(level='E', note='Когда ж локализации у моделей будут?',
    pattern=[
      '//ClassDef[@name="Post"]' '//ClassDef[@name="Meta"]' '//*[@id="verbose_name"]',
      '//ClassDef[@name="Post"]' '//ClassDef[@name="Meta"]',
      '//ClassDef[@name="Post"]',
    ],
    formula='not hits._0 and (hits._1 or hits._2)', 
    position='max(hits._1.top, hits._1.top)',
),
``` 
*Пояснения.*  
- Шаблоны начинаются на `/` - это XPath-запросы к AST-XML-дереву.  
- `formula='...'` - текст формулы, которая после eval() скажет "успешен ли поиск".  
- `position='...'` - текст формулы, которая после eval() скажет "номер строки, куда коммент вставлять".  
- `//ClassDef[@name="Post"]` - ловим класс `Post` от корня дерева.  
- `//ClassDef[@name="Meta"]` - ловим вложенный класс `Meta`.  
- `//*[@id="verbose_name"]` - ловим любой узел внутри `Meta` с таким атрибутом, то есть поле.  
Можно было написать полный путь  
    `/body/Assign/targets/Name/*[@id="verbose_name"]`  
но на результат это не повлияет.  
- `hits._0` набор найденных фрагментов от первого шаблона.  
- Вычисление `not hits._0` будет давать Да, если поиск провалился (фрагменты не найдены).  
- Вычисление `(hits._1 or hits._2)` будет давать Да, если успешен хоть один из поисков по второму или третьему шаблону.  
- `hits._1.top` - номер верхней строки у фрагмента найденного вторым шаблоном.  
- Так как `.top` для ненайденных возвращает -1, 
`max()` даст либо номер строки с `class Post` (если нет `Meta`), либо номер строки с `class Meta`.  

**(Вариант 2) Сахар**-шаблоны в `pattern` заданы **словарем**
```python
dict(level='E', note='Когда ж локализации-то будут?',
    pattern=dict(good=dedent('''\
        class Comment■
            ◊
            class Meta:‡
                ◊
                verbose_name =''',
                        only_meta='''
        class Comment■
            ◊
            class Meta''',
                        only_clss='''
        class Comment'''),
    ),
    formula='not hits.good and (hits.only_meta or hits.only_clss)', 
    position='max(hits.only_meta.btm, hits.only_clss.btm)',
),
```
*Пояснения к новым деталям.*  
- `■` - любые символы в пределах этой же строки.  
- `◊` - любое количество (в тч нулевое) строк с таким же отступом (тут 4/8 пробелов).  
Внимание! Такая разметка опирается на предположение, что в классе будет соблюдаться дисциплина отступов.  
- `hits.good` инфа про результат поиска шаблоном `good=...`.  
- Вычисление `not hits.good` будет давать Да, если поиск провалился (инфа пустая).  
- Вычисление `(hits.only_meta or hits.only_clss)` будет давать Да, если если найден класс с Мета или только сам класс `Comment`.  
- `hits.only_meta.btm` номер последней строки для найденного фрагмента (тут от шаблона `only_meta=...`).  
- Так как `.btm` для ненайденных возвращает -1, вычисление  
    `max(hits.only_meta.btm, hits.only_clss.btm)`  
даст нижнюю строку от одного из найденных фрагментов.
    

### Не хватает локализации поля в модели
Поиск случаев, когда у поля `ForeignKey` в модели нет перевода.  
**Логика поисков**  
    Если не найден `verbose_name` внутри `author=models.ForeignKey()` или `author=ForeignKey()`,  
    то нужен комментарий к `author=`.  

**Размещение**: в файле знаний для проверки проектов с моделями  
```python
{
  '.*models.py':[тут],
}
```
**Варианты АР-словарей**  
  
**(Вариант 1) **XPath**-шаблоны в `pattern` заданы **списком**  
```python
dict(level='E', note='Когда ж локализация у поля будет?',
    pattern=[
      '//Assign[targets/Name[@id="author"]]',
      '//Assign[targets/Name[@id="author"]]'
       '/value/Call[//*[@attr="ForeignKey"] or //*[@id="ForeignKey"]]'
        '//keyword[@id="verbose_name"]',
    ],
    formula=' hits._0 and not hits._1', 
    position='hits._0.top',
),
``` 
*Пояснения.*  
- Шаблоны начинаются на `/` - это XPath-запросы к AST-XML-дереву.  
- `//Assign[targets/Name[@id="author"]]` - ловим код `author=` от корня дерева.  
- `'/value/Call[//*[@attr="ForeignKey"] or //*[@id="ForeignKey"]]` - ловим `=model.ForeignKey()` или `=ForeignKey()`.  
- `'//keyword[@id="verbose_name"]'` - ловим параметр внутри этого вызова.  
- `formula='...'` - текст формулы, которая после eval() скажет "успешен ли поиск".  
- `position='...'` - текст формулы, которая после eval() скажет "номер строки, куда коммент вставлять".  
- `hits._0` - набор найденных фрагментов от первого шаблона.  
Вычисление `not hits._1` будет давать Да, если поиск провалился - `verbose_name` не найден для второго шаблона.  
- `hits._0.top` - номер верхней строки у фрагмента найденного первым шаблоном.  

**(Вариант 2) Сахар**-шаблоны в `pattern` заданы **словарем**
```python
dict(level='E', note='Когда ж локализация у поля будет?',
    pattern=dict(
        good='class Post‡author = ForeignKey(‡verbose_name‡)',
        bad='class Post‡author = ForeignKey(╔verbose_name╗)',
    ),
    formula='not hits.good and hits.bad)', 
    position='hits.bad.btm',
),
```
*Пояснения новых деталей.*  
- `Post‡author` - захват имени класса и его (тк ближайшего) поля автор.
- `(‡verbose_name‡)` - так как `‡` захватывает минимальные фразы, этот поиск захватит фразу от скобки до скобки,
если внутри **есть** `verbose_name`.  
- `(╔verbose_name╗)` - будет успешный захват от скобки до скобки, если внутри **нет** `verbose_name`.  
- `hits.good` - инфа про результат поиска шаблоном `good=...`.  
- Вычисление `not hits.good` будет давать Да, если поиск провалился (инфа пустая).  
- `hits.bad.btm` номер последней строки для найденного фрагмента (тут от шаблона `bad=...`).  

**(Вариант 3) Сахар**-шаблоны в `pattern` заданы **словарем**.  
Имя поля запоминается и подставляется.  
```python
dict(level='E', note='Когда ж локализация у поля будет?',
    pattern=dict(
        field='≤name≡class Post‡author≥ = ForeignKey(‡)',
        good='{{hits.field.txt}} = ForeignKey(‡verbose_name‡)',
        bad='{{hits.field.txt}} = ForeignKey(╔verbose_name╗)',
    ),
    formula='not hits.good and hits.bad)', 
    position='hits.bad.btm',
),
```
*Пояснения новых деталей.*  
- `≤name≡class Post‡author≥` - захват названия поля у Поста в именованную группу.  
Тут ищется поле `author` и создается группа `name`.  
- `{{hits.field.txt}}` - подстановка ранее найденного фрагмента.

### Не хватает типа у извлекаемого параметра при регистрации маршрута
(*В разработке*)
### Неудачное имя параметра при объявлении маршрута
(*В разработке*)
### Неуместное применение фильтра вместо опоры на related_name
(*В разработке*)
### Избыточное дублирование деталей кода
(*В разработке*)
### Размещение действий в неуместном методе
(*В разработке*)
### Ошибочное параллельное применение logger.error() и logging.error()
(*В разработке*)
</details>


# Технические детали  


## Структура словаря знаний (АР-словарь) <a name=rv-dict></a>  

**Внедряемые ключи** <a name=implant></a>   
Любой ключ, если не задан явно, может получить значение из окружающего словарь набора.  
Например, его можно указать  
    в словаре `defaults` на уровне [файла](#rv-file) с этим АР-словарем,  
    в `opts.defaults` в файле `autorv2.cfg.py` (или его заменяющем),  
    в опции [запуска](#opts_install).  
То есть это "вынесение за скобки" для повторяющихся значений.  

**Обязательные ключи** <a name=need-keys></a>  

- `level` <a name=levl></a>  
    `'G'`|`'F'`|`'E'` - **G**ood/похвала, **F**alse/совет, **E**rror/ошибка.  
**Уровень** выходного комментария.  
- `pattern` <a name=pttn></a>  
    строка|список-строк|словарь-со-строковыми-значениями  
**Шаблон(ы)** для поиска.  
Один шаблон для поиска может быть  
    регуляркой/сахаром (может начинаться с `re:`)  
или  
    XPath-выражением для AST-дерева (может начинаться с `xpath:`).  
Если нет явного указания `re:`/`xpath:`, то  
    шаблоны начинающиеся на `/` считаются `xpath:`,  
    остальные `re:`.  
В случае успешного поиска (расчет успеха может уточняться в формуле из `formula`)  
формируется номер строки (ее расчет может уточнять в формуле из `position`) для вставки комментария.  
После поиска порождает runtime-[след](#pttn_rt) `hits`.  
После формирования комментария попадает в runtime-[след](#succ_hits) `comments`.  
- `note` <a name=note></a>  
    строка|список-строк|словарь-со-строковыми-значениями  
Комментарий или **варианты комментариев**.  
Для первого найденного случая, то есть набора находок по шаблонам, применяется первый комментарий, для второго - второй и т.д.  
Если случев больше, то будет применяться последний вариант.  
После формирования комментария попадает в runtime-[след](#succ_hits) `comments`.  
    
**Ожидаемые ключи** <a name=waited-keys></a>  

- `repeats` <a name=rpts></a>  
    `'as-note'`|`'one'`|`'all'`|`число`  
    Если поисковый шаблон один, то умолчание: `'as-note'`.  
Настройка **повторных комментирований** в пределах одного файла-исходника.  
`'as-note'` - комментировать не больше, чем вариантов в `note`.  
`'one'` - комментировать только первый случай.  
`'all'` - комментировать все найденные случаи, повторяя последний элемент `note` при необходимости.  
`число` - комментировать указанное число случаев, повторяя последний элемент `note` при необходимости.  

- `formula` <a name=frml></a>  
    Умолчание: `''`  
Текст формулы, по которой будет eval-вычисляться **успех поиска**.  
Умолчание - "есть хоть одна находка" - по формуле `any(hits.values())`.  
Например, при настройке  
    `formula='hits._0 and hits._2'`  
поиск будет успешным, если первый и третий шаблон успешны.

- `position` <a name=posi></a>  
    Умолчание: `''`  
Текст формулы, по которой будет eval-вычисляться **номер строки** исходника для вставки.  
Умолчание - "самая нижняя строка у найденных фрагментов" - по формуле  
    `max(hit.btm for hit in hits.values())`.  
Пример явной настройки  
    `position='min(hits._0.top, hits._1.btm, -1)'`.  

- `wo_strip` <a name=wo_strip></a>  
    Умолчание: `''` - выполнять strip-ы.  
Флаг для **пропуска** `.strip('\n')` для всех значений у `pattern` и `note`.  
Умолчание позволяет свободнее оформлять знания, но может мешать точному поиску/вставке.  
- `wait_re` <a name=wait_re></a>  
    Умолчание: `''` - ожидать сахар.  
Флаг для переключение c ожидания сахара на **ожидание регулярки**.  
Умолчание настроено на то, что регулярки появляются только внутри `«...»`.  
При любом непустом значении сахар ожидается внутри `«...»`.  
- `end_sign` <a name=end_sign></a>  
    Умолчание: `''`  
Завершающее дополнение для комментария.  
Удобно разместить это дополнение в `defaults`, то есть в настройках для всех АР-словарей модуля.
Тогда получится **"подпись модуля"** ко всем комментариям.  
Так как в разных файлах могут быть разные подписи, будет видно из какого файла АР брал знания.  

- `name` (идентификатор) <a name=name></a>  
    Умолчание: `''`  
Имя контекстной **переменной для подстановок** в другие знания.  
Например, `name='имя'` позволит подставлять в других АР-словарях  
    `{{имя.level}}`,  
    `{{имя.comments._0.row}}` - где встален...  
    `{{имя.comments._0.txt}}` - ...такой комментарий...  
    `{{имя.comments._0.hits}}` - ...так как были такие находки.  
Можно организовывать цепочки знаний и/или условные комментирования.  


- `clog` <a name=clog></a>  
    `1`|`2`|`3`  
    Умолчание: `''`  
При непустом значении включается логгирование операций с текущим АР-словарем.

**Runtime-следы** - ключи, доступные только после выполнения поиска или комментирования <a name=rt-keys></a>  
Для каждого нового исходника эти ключи заполняются заново.  

- `hits` <a name=pttn_rt></a>  
    словарь словарей  
Словарь (мб с пустыми элементами!), содержащий инфо про **текущий набор находок**. 

   Если `pattern` был задан строкой, то `hits` имеет вид:  
    `{'_':инфо}`  
Если `pattern` был задан списком, то ключами станут `_позиция`:  
    `{'_0':инфо,'_1':инфо,}`  
Если `pattern` уже был словарем, например `{'up':'...','dn':'...'}`, то ключи сохранятся:  
    `{'up':инфо,'dn':инфо,}`  
Внутри словаря *инфо* будут такие ключи  
– `'top':номер-строки-на-начало-найденного-фрагмента`,  
– `'btm':номер-строки-на-конец-найденного-фрагмента`,  
– `'txt':найденный-фрагмент`,  
– `'txt_имя':фрагмент-найденной-групы-с-указанным-именем`.  
– `'top_имя':номер-строки-на-начало_фрагмента-с-указанным-именем`.  
– `'btm_имя':номер-строки-на-конец_фрагмента-с-указанным-именем`.  
Если шаблон неуспешен, то формируется пустой словарь *инфо*, но обращения к его ключам будут работать:  
    `'top'`/`'top_имя'`/`'btm'`/`'btm_имя'` дадут -1,  
    `'txt'` и `'txt_имя'` дадут пустую строку.  
В словаре сохраняются только именованные re-группы, в том числе с [сахар-именами](#frag-name) фрагментов.  

- `comments` <a name=succ_hits></a>  
    список словарей  
Если [задан](#name) `name`, то формируется список всех **успешных применений**, содержащий словари с ключами  
– `'row'` - местом комментария,  
– `'txt'` - текст комментария,  
– `'hits'` - набор *инфо* про находки (структура как у [hits](#pttn_rt)).  
Например, если есть `name='имя'`, то через  
    `имя.comments._0.row`  
    `имя.comments._0.cmnt`  
в других знаниях можно будет выяснить, где и какой тут применился первый комментарий.  
А через  
    `имя.comments._0.hits._0.txt`  
    `имя.comments._0.hits._1.txt`  
узнать из каких находок он составлен.

**Модификаторы значений**  

**Подстановки** <a name=subs-mod></a>  
Любое значение (в том числе из списка/словаря) у обязательных/ожидаемых ключей (кроме `formula` и `position`) может 
начинаться с модификаторов  
- `+t:` (умолчание для всех кроме `formula` и `position`)  
Нужны подстановки вида `{{имя}}`, где "имя" указывает на контектную переменную.  
- `+t{{{}}}:`  
Нужны подстановки вида `{{{имя}}}`.  
- `+te:`  
После подстановок вида `{{имя}}` требуется `eval()`.  
- `+te<<>>:`  
После подстановок вида `<<имя>>` требуется `eval()`.  
- `+v:` (умолчание для `formula` и `position`)  
Требуется `eval()` с передачей контекстных значений как локальных переменных.  

Между `+t`/`+te` и `:` могут указываться явные "парные скобки" для выделения имени подставляемого значения.  
Умолчательные "парные скобки" - `{{}}`.  
Примеры  
```python
dict(...,pattern={'nm':'lala'},...),                              # ищем lala
dict(...,pattern='+t:def «{{hits.nm.txt}}{{hits.nm.txt}}»(',...), # ищем def lalalala( (подходит для поисков в питоне)
dict(...,pattern='+t<<>>:<br>«<<hits.nm.txt>>»',...),             # ищем <br>lala (подходит для поисков в шаблоне)
dict(...,pattern='+te:"«{{hits.nm.txt}}»"[:2]',...),              # ищем la
dict(...,formula='hits.nm.txt[:2]=="ok"',...),                    # проверяем "la"=="ok"
```
  
Для значений у `formula` и `position` эти модификаторы избыточны, так как eval применятся всегда и 
необходимости применять `{{}}` нет.  

В значениях `pattern` подстановки находок от предыдущих поисков и/или предыдущих знаний допустимы, 
но должны размещаться [внутри](#isolator) `«...»` или `<!<...>!>`.


**Локализации (еще в разработке)** <a name=pttn_ast></a>  
Значения из `pattern` могут содержать указания на анализ локализации в AST-дереве.   
Для этого они должны начинаться с модификатора:  
    `'+ast:'`  
Тогда в rt-следе для этого значения появится новый ключ  
    `'ast':'локализация'`  
с одним из значений  
    `''` - нет однозначной локализации,  
    `'str'` - фрагмент локализован внутри строкового литерала,  
    `'com'` - фрагмент локализован внутри комментария,  
    `'doc'` - фрагмент локализован внутри док-строки.  
  
Значения из `pattern` могут содержать конкретные ограничения на локализацию в AST-дереве.   
Для этого они должны начинаться с одного из модификаторов:  
    `'+ast-in-str:'` - весь найденный фрагмент должен находиться внутри строкового литерала.  
    `'+ast-in-com:'` - весь найденный фрагмент должен находиться внутри комментария.  
    `'+ast-in-doc:'` - весь найденный фрагмент должен находиться внутри док-строки.  
При этом в rt-след всегда добавляется ключ `'ast':'локализация'` 
и умолчательная формула `formula` дополняется его анализом.  
  
Модификаторы локализаций размещаются раньше модификаторов подстановок.  
  
Примеры.  
- Поиск `om` только в виде `par='home'`, но не в виде `home='par'`.  
   ```python
   dict(...,pattern='+ast-in-str:om',...),
   ```
- Поиск `om` только внутри комментариев и док-строк.  
   ```python
   dict(...,pattern='+ast:om',formula='hits._.ast in "com doc"',...),
   ```


## Структура файла знаний с АР-словарями <a name=rv-file></a>  
Файл должен содержать один глобальный словарь вида  
```python
{
   'defaults': {
      'ключ-АР-словаря': 'значение',
      'ключ-АР-словаря': 'значение',
   },
   'регулярка-на-путь-внутри-zip-к-файлу-исходника': [
      АР-словари
   ],
   'регулярка-на-путь-внутри-zip-к-файлу-исходника': [
      АР-словари
   ],
}
```

- Часть `defaults:{}` необязательная.  
Внутри могут указываться любые [обязательные](#need-keys) и [ожидаемые](#waited-keys) ключи АР-словаря, 
в том числе, неописанные в этом доке.  
Всем указанным тут ключам во всех АР-словарях **этого файла** будут назначены указанные значения, 
**если** ключа в АР-словаре нет.

   Примеры.  
   - Можно инвертировать размещения сахаров и регулярок в [изоляторах](#do-sugar) `«...»` 
   через `'wait_re':'T'`.  
   - Можно всем комментариям один раз задать уровень **Надо исправить** через `'level':'E'`, 
   а для некоторых потом явно указывать другие уровни.  
   - Удобно для разных файлов назначить разные "подписи АР" через `end_sign`.  
   Тогда будет видно "из какого файла" АР брал комментарий. 
   - Можно поменять умолчательное место для вставки комментария:  
       с последней найденной строки  
       на первую,  
   указав формулу через `position`.  

   Часть ключей (или все) из `defaults` можно перенести "выше", то есть сделать глобальными, 
   указывая их в [дереве настроек](#own-opts) в словаре `opts.defaults`.  
   Кроме того, для `opts.defaults` можно задавать ключи через опцию [запуска](#run-opts) `-d`.

- Интерференция регулярок на пути внутри zip.  
   Будут применяться все АР-словари:    
   - Одна регулярка может отбирать несколько путей для исходников.   
   - Один путь к исходнику может подходить нескольким регуляркам.  
   
   Гарантируется, что применения будут в порядке, указанном в файле сверху-вниз.  


## Сборка знаний для одной домашки <a name=build></a>  
Знания для одного типа домашек полезно размещать в нескольких файлах.  
Например, выгодно держать претензии в языку отдельно и включать во все ревью.  
Кроме того, выгодно применять знания от предыдущей домашки из серии.

В [настройках](#opts_install) АР за сборку АР-файлов отвечает ключ `skills` из `opts`:  
```python
opts = dict(
    skills=dict(
        ключ_домашки=dict(
            skills=[
               файл-знаний-1,
               файл-знаний-2{условие отбора АР-словарей из этого файла},
               ...
            ],
        ),
    ),
)
```
Пояснения

1. Ключи домашек не произвольные! Они должны быть согласованы с другими частями настройки.  
Желательно применять предложенные в репо.
1. Файлы в списке по `skills` указываются по абсолютным или по относительным путям.  
Важно! Относильные к `autorv2.py`, а не к текущей папке запуска.  
Пример.  
   ```python
   opts = dict(
       skills=dict(
           b1=dict(skills=[
               'skills/base_skills2.py',
               'skills/b1_skills2.py',
           ]),
       ),
   )
   ```

1. Условие отбора - это питон-код, в котором проверяемый АР-словарь доступен через переменную `ard`, 
кроме того будут доступны глобальные констант от [опций](#run-opts) запуска и/или [монитора](#monitor).  
Пример.  
    ```python
    opts = dict(
        skills=dict(
            b2=dict(skills=[
                'skills/b1_skills2.py{ITER==1 and ard.level=="E"}',
                'skills/b2_skills2.py',
            ]),
        ),
    )
   ```
   Из `b1_skills2.py` будут применяться только претензии про ошибки и только на первой итерации.


## Слияния комментариев от нескольких АР-словарей <a name=merge_comments></a>  
Если к одной строке исходника АР нашел несколько вариантов комментариев, 
то умолчательный алгоритм их смешивания такой:

- Общий уровень комментария задается  
   - как **Отлично**, если такой есть среди вариантов,  
   - иначе как **Надо исправить**, если такой есть среди вариантов.  
- Сначала размещаются варианты с выбранным общим уровнем.  
- За ними размещаются варианты с одинаковыми уровнями: от **Можно лучше** к **Надо исправить**.  
- Если вариантов с общим уровнем несколько, они оформляются a-la "нумерованным" списком:  
   - добавляется разделяющая пустая строка,  
   - добавляется в начало комментария `(N) `, где N его номер в группе с одинаковым уровнем.  

После форка умолчательный алгоритм доступен для модификации - достаточно подменить вызов функции  
    `simple_render(набор-комментариев)`.  

**Пример 1**  
Есть набор для комментирования:  
    F, 'false 1'  
    F, 'false 2'  
    G, 'good'  
    E, 'error'  
Тогда комментарий получится такой
```
   good
   
   **Можно лучше**
   (1) false 1
   
   (2) false 2
   
   **Надо исправить**
   error
   
      Отлично
```
**Пример 2**  
Есть набор для комментирования:  
    F, 'false 1'  
    E, 'error 1'  
    E, 'error 2'  
Тогда комментарий получится такой
```
   (1) error 1
   
   (2) error 2
   
   **Можно лучше**
   false 1
   
      Надо исправить
```

## Сахара  

### Порядок применения <a name=do-sugar></a>  
- Выделяются сахарные части.  
Они могут быть вне (умолчание) или внутри изоляторов `«...»` в зависимости от `wait_re`.  
- Для каждой сахарной части  
   - Экранируются все знаки натур-регулярок.  
   - В цикле пока происходит хоть одна замена:  
      - Выполняются подмены всех свободных сахаров.  
      - Выполняются подмены всех плагинных сахаров.  
   - Выполняются подмены всех зашитых сахаров (пока это только `↓1`).  

Цикл по заменам означает, что в подменяемой части могут оказываться 
новые сахара - как свободные, так и зашитые.  
**Внимание!** Так как после подмены сахара ожидаются регулярки, 
сахара в подменах обязаны быть внутри изоляторов `«...»`.

### Зашитые (неподменяемые!) сахара <a name=in-sugar></a>
- `«шаблон»` <a name=isolator></a>  
`<!<шаблон>!>`  
**Изолятор**  
В зависимости от значения ключа `wait_re` внутри "лапок" может быть  
    питон-регулярка (если `wait_re` пустой),  
    сахарная разметка (при непустом `wait_re`).  
Изоляторы не могут быть вложенными, но могут появляться при замене свободных сахаров.

- `↓1` ... `↓9` ... <a name=row-num></a>  
`<~ROW>1` ... `<~ROW>9` ...  
**Номера найденных строк**  
Запоминание номера строки, в которой находится такой знак.  
Эти номера можно будет вставлять в формулы через  
    `_.↓1` ... `_.↓9`  
    `_.<~ROW>1` ... `_.<~ROW>9`  
в шаблоны и комментарии через  
    `{{_.↓1}}` ... `{{_.↓9}}`  
    `{{_.<~ROW>1}}` ... `{{_.<~ROW>9}}`  
Вместо  
    `_.`  
может быть  
    `_0.`/`_1.`,  
если шаблоны заданы списком, или  
    `ключ.`,  
если шаблоны заданы словарем.

<details><summary>Явные регулярки</summary>  

Применяются такие регулярные выражения

| Сахар         | Применение в заменах          | Комментарий  |
| --            | --                            | --           |
| `↓1`          | `↓(\d)` заменяется на `(?P<_rOw_\1>(?<!↓))` | Не будет захваченных символов | 

</details>

### Плагинные штатные сахара <a name=plug-sugar></a>
- `►так▲и так▲и эдак◄`  
`<~LF_VAR>так<~VAR>и так<~VAR>и эдак<~RT_VAR>`  
**Варианты фрагментов** <a name=vars></a>  
Указываются варианты разметки.  
Ограничение: внутри вариантов не должно быть `►` `▲` `◄`.  

- `‡` <a name=strap></a>  
`<~TIE>`  
**Стяжка**  
Минимальный заполняющий текст (возможно пустой), в том числе, содержащий концы строк.  
- `(‡)` `[‡]` `{‡}` <a name=bracks></a>  
`(<~TIE>)` `[<~TIE>]` `{<~TIE>}`  
**Фрагмент в парных скобках**  
От открывающей до ее *парной* закрывающей.  

- `╣фраза╣` <a name=no-next-frag></a>  
`<~NO_AFTER>фраза<~NO_AFTER>`  
**Лишний текст ПОСЛЕ чего-то**  
Фразы не должно быть *за* очередным подходящим символом.  
- `╠фраза╠` <a name=no-prev-frag></a>  
`<~NO_BEFORE>фраза<~NO_BEFORE>`  
**Лишний текст ПЕРЕД чем-то**  
Фразы не должно быть *перед* очередным подходящим символом.  
- `╔фраза╗` <a name=not-in-frag></a>  
`<~NOT_IN_LF>фраза<~NOT_IN_RT>`  
**Лишний текст МЕЖДУ чем-то и чем-то**  
Фразы не должно быть *внутри* подходящих символов слева и справа.  

- `≤имя≡подшаблон≥` <a name=frag-name></a>  
`<~GRP_NM>имя<~GRP_OP>подшаблон<~GRP_CL>`  
**Именованный захваченный подфрагмент**  
Через назначенное имя можно будет применять как `hits.txt_имя` в ключах АР-словаря. 
Например, опираться на него в логике или вставлять целиком в конечный комментарий.

- `◊` <a name=same-gap></a>  
`<~GAP>`  
**На том же уровне отступа**  
Минимальный фрагмент из нескольких строк (м.б. 0) с такими же (не меньше) сдвигами до начала текста.  

- `espanso:триггер` <a name=espanso></a>  
**Подстановка из espanso по триггеру**  
Если в настройках espanso есть указанный триггер, то произойдет подмена.  

   Внутри такой подстановки могут применяться "номера найденных строк" через `↓0`..`↓9`.  
Ограничение! Такие подстановки будут работать только для `pattern` заданного строкой, но не списком или словарем.

<details><summary>Явные регулярки</summary>  

Применяются такие регулярные выражения

| Сахар         | Регулярка или применение в заменах | Комментарий |
| --            | --                   | -- |
| `►` `▲` `◄`   | `►([^▲]+)▲([^◄]+)◄` заменяется на `((\\1)\|(\\2))` (остальные аналогично) | Ожидаются \<10 вариантов |
| `‡`           | `(?s:.*?)`           | Общий знак `‡` тут и ниже |
| `(‡)`         | `\([^\(\)]*?(?:\([^\(\)]*?(?:\([^\(\)]*?\)[^\(\)]*?)*?\)[^\(\)]*?)*?\)` | Глубина вложенности \<3|
| `[‡]`         | `\[[^\[\]]*?(?:\[[^\[\]]*?(?:\[[^\[\]]*?\][^\[\]]*?)*?\][^\[\]]*?)*?\]` | Глубина вложенности \<3|
| `{‡}`         | `\{[^\{\}]*?(?:\{[^\{\}]*?(?:\{[^\{\}]*?\}[^\{\}]*?)*?\}[^\{\}]*?)*?\}` | Глубина вложенности \<3|
| `╣XX╣`        |  заменяется на `(?!XX)`| негативное заглядывание ВПЕРЕД |
| `╠XX╠`        | заменяется на `(?<!XX)`| негативное заглядывание НАЗАД |
| `╔XX╗`        | заменяется на `(?!(?s:.*?)XX)(?s:.*?)`| негативный поиск МЕЖДУ |
| `≤name≡XX≥`   | заменяется на `(?P<name>XX)` |              | 
| `◊`           | `\n( *)◊` заменяется на `(\n\\1.*)*?` |  |

</details>

### Свободные (подменяемые!) сахара <a name=free-sugar></a>
Умолчательный набор указывается в `autorv2_free_sugars.py`.  
Там же можно удалять, подменять значения или добавлять свои сахара.  
  
Умолчательный набор  

- `‡‡` `<~ID0>` - **часть идентификатора** <a name=free_id></a>  
Текст (возможно пустой) из букв/цифр/_/точки.  
- `■` `<~FILLER>` - **обязательный заполнитель** <a name=free_1_fill></a>  
Любой непустой текст в пределах строки.  
- `□` `<~FILLER0>` - **заполнитель** <a name=free_0_fill></a>  
Любой текст в пределах строки.  
- `○` `<~BLANKS0>` - **пробельные символы** <a name=free_0_blanks></a>  
Несколько пробелов/табов/EOL (может быть 0).  
- `▫` `<~SPACES0>` - **пробелы** <a name=free_0_spaces></a>  
Несколько пробелов (может быть 0).  
- `▪` `<~BLANKS>` - **обязательные пробельные символы** <a name=free_1_blanks></a>  
Несколько пробелов/табов/EOL.  
- `†` `<~QUOTE>` - **кавычка** <a name=free_quote></a>  
Либо `'`, либо `"`.  
- `∞` `<~ENDDOC>` - **последний символ** <a name=free_enddoc></a>  
Позволяет находить конец файла. Находка будет даже в пустом файле.

<details><summary>Явные регулярки</summary>  

Применяются такие регулярные выражения  

| Символ  | Регулярка  | Комментарий |
| --      | --         | -- |
| `‡‡`    | `[\w\.]*`  |    |
| `†`     | `[\'\"]`   |    |
| `□`     | `.*`       | Мнемоника: пустой символ = "от 0"|
| `■`     | `.+`       | Мнемоника: непустой символ = "от 1"|
| `○`     | `\s*`      | Мнемоника: пустой символ = "от 0"|
| `▪`     | `\s+`      | Мнемоника: непустой символ = "от 1"|
| `▫`     | ` *`       | Мнемоника: пустой символ = "от 0"|
| `∞`     | `.$`       |    |

</details>


## Порядок обработки и контекстные переменные <a name=actions></a>  


### Порядок обработок <a name=order></a>  
1. Каждый исходный файл из zip обрабатывается независимо.  
В частности, нет возможности предсказывать какой их двух файлов будет обработан первым.  
1. Порядок применения АР-словарей для одного исходного файла жесткий.  
   - Гарантируется, что АР-словари внутри одного файла знаний будут обрабатываться сверху вниз.  
   - Порядок применения разных файлов знаний фиксирован в [сборке](#build).  
1. АР-словари могут опираться на результаты применения предыдущих АР-словарей, если у них задан [ключ](#name) `name`.  

### Контекстные переменные <a name=context></a>  
Подстановка `{{ЛюБоЕиМя}}` никогда не дает сбоя, если в контексте нет такой переменной.  
Если такая переменная может быть в контексте, например, это ключ АР-словаря, то будет подставляться умолчание.  
В остальных случаях будет подставляться пустая строка.

**Глобальные контекстные переменные** <a name=global-context></a>  
- `{{HW_ZIP_PATH}}` - **полный путь** к исходному zip.
- `{{HW_ZIP_FN}}` - **имя файла** zip.
- `{{SRC_PATH}}` - **путь** обрабатываемого исходного файла внутри zip.
- `{{SRC_FN}}` - **имя** обрабатываемого исходного файла внутри zip.
- `{{ITER}}` - **номер итерации** (добавит [Монитор](#monitor), если он вызывает АР).
- От [настроек](#opts_install) (в том числе от опций запуска) могут поступать дополнительные глобалы.

**Внутренние переменные АР-словарей** <a name=dict-context></a>  
Подробности в описании runtime-следов [hits](#pttn_rt) и [comments](#succ_hits).

## Система настроек. Развертывание АР2 <a name=opts_install></a>  
Шаги для запуска АР2

### (Шаг 0) Добыть код
Клонировать [репозиторий](https://github.com/kvichans/autorv2).  
Применить при необходимости зависимости из `requirements.txt`.  

### (Шаг 1) Создать АР-файл(ы)
Создать личный(е) [файл(ы) знаний](#rv-file).  
Например, разместить их в поддапке `autorv2/skills`, которая применяется по умолчанию.  

Там уже есть один полу-готовый АР-файл `snake_demo_skills2.py`, - в нем поиски для 23 случаев из чек-листа Змейки настроены, 
а комментарии к ним нужно заменить на содержательные.  
Этот "демо" можно использовать для создания других АР-файлов как шаблон или как набор примеров.
А еще там же есть почти пустые заготовки для всех домашек.  
На эти заготовки уже есть настройка в `opts.skills` - осталось их наполнить.

### (Шаг 2) Заполнить файл с личными настройками. <a name=own-opts></a>  

- Настройки АР2 - это дерево с корнем `opts`, которое получается от перекрытия трех *слоев*.  
   - Есть "*зашитые*" - они в `def_opts.py`.  
Рекомендется их изучить, но не менять (на начальном этапе).  
   - Есть "*личные*" - они по-умолчанию в `autorv2.cfg.py`.  
Их нужно отредактировать на месте или разместить в другом файле.  
   - Есть "*сессионные*" - они задаются опциями CLI-запуска `-o`/`--opt`.  
Их можно применять при уникальных случаях, когда изменения "личных" избыточны.
   - Каждый следующий слой дополняет и перекрывает предыдущие.  
Перекрытие происходит, если задан такой же конечный ключ.  
Дополнение происходит, если задан новый ключ на любом уровне дерева.

- Файл `autorv2.cfg.py`.  
Если ничего при запуске не задавать, то "личные" настройки будут извлекаться из него.  
- Можно иметь свой файл и указывать его через ключ `-g`/`--config`.  
Например, если личные настройки оказались в `config-ar2.py`, тогда обработка зипа будет выполняться такой командой  
    `py10 autorv2.py -g config-ar2.py файл-с-домашкой.zip`  
- При использовании `-g`/`--config` можно подавать не Python-исходник, а файл в формате YAML или JSON.
- Внутри `def_opts.py` и `autorv2.cfg.py` уже есть пояснения, как заполнять "личные настройки".  
Вот что нужно знать

   - Нужно заполнить словарь `skills`, указывая ключи домашек и подходящие АР-файлы.  
   Для каждой домашки будет одна ветка. Например, ветка Змейки получится такого вида  
       ```python
       skills=dict(
          snk=dict(
             skills=[АР-файл-1, АР-файл-2],
          ),
       ),
       ```
   
   - АР-файлы могут быть в формате Python/YAML/JSON.
   - Все относительные пути в каждом АР-файле (точнее это регулярки) будут дополняться слева папкой, 
   в которой АР найдет сигнальный файл (см `main_dir_if_has_any_files` в `def_opts.py`).
   Например, для Змейки это файл `the_snake.py`.
   - Можно задавать содержимое `opts.defaults`.  
   Например, менять умолчательный уровень замечаний и/или подписи и/или зоны изоляции.
   - Можно указывать наполнение контекста `opts.context`, то есть глобальных констант для гибкого управления.
   - (Позже) Можно фильтровать АР-словари.  
   Например, это полезно для переноса части АР-словарей "из предыдущей домашки".

### (Шаг 3) Запуск. <a name=run-opts></a>  
При запуске нужно обязательно указывать только зип домашки.  
Через необязательные опции можно дополнить и/или перекрыть 
"личные" настройки (из `autorv2.cfg.py` или своего) и/или "умолчательные" из модуля `def_opts.py`.  
   - Например, вот так можно подменить второй АР-файл для Змейки (личные настройки в `autorv2.cfg.py`) на `MY.JSON`  
       `py10 autorv2.py -o skills.snk.skills._1=MY.JSON домашка.zip`  
   - Есть специальный аварийный ключ для ситуаций, когда АР2 не справляется по настройкам  
       `-hk`/`--hw_key`  
   Он позволяет пропустить распознавание домашки по зипу и вложенной папке - явно указать ключ, 
   по которому будут применяться АР-файлы.  
   Такой ключ будет спасать, когда студент сдает уникально названный/скомпонованный зип.  
   - Можно менять/задавать ключи глобального `opts.defaults` через опцию `-d`/`--default`  
       `py10 autorv2.py -d level='E' -d repeats=2 файл-с-домашкой.zip`  
   - Можно менять/задавать глобальные константы `opts.context` через опцию `-c`/`--context`  
       `py10 autorv2.py -c ITER=2 -c SMTH='...' файл-с-домашкой.zip`  

### (Шаг ∞) А дальше... <a name=use-loop></a>  
Дальше нужно повторять шаги.

- (Редко) Обновлять репу, когда в ней появятся свежие "вкусности".  
Для этого полезно следить за [Историей обновлений](#name=hist).
- (Часто) Дорабатывать свои АР-файлы.  
В пределе можно покрыть все домашки и переложить а АР значительную часть ревью.  
Например, в Змейке можно через АР делать 90% комментариев.  
В Джанго-тестах - 60%.  
В DRF-командный - 40%.  
В Фудграме - 30%.  
- (Редко) Дорабатыть свое дерево настроек.

Можно идти еще дальше.
- Освоить [Монитор](#monitor), чтобы избавиться от примитивной работы "запуск АР после скачивания зипа".  
Кроме того, Монитор помогает запускать "сравнивающую утилиту" (WinMerge?), которой так не хватает в Ревизоре.  

   Не обязательно пользоваться Монитором для этих целей.  
Сторонняя утилита [prpr](https://github.com/Roxe322/prpr) может автоматически скачивать зипы и 
запускать их пост-обработку (например, вызывать АР, запускать дифф и пр).

- Освоить [espanso](https://espanso.org/) и настроить АР-словари на его [применение](#espanso).  
Это позволит иметь общую базу заготовок для ручного ревью и для АР.


# Дополнительные сервисы


## АР-шелл для отладки сахарных шаблонов <a name=shell></a>  
При запуске с опцией `-sh`/`--shell` АР2 предоставляет CLI-диалог - **АР-шелл**, 
в котором можно конвертировать сахара в регулярки.
Можно дополнительно указать одно значение для `note` и текст для поиска, тогда шелл покажет,
какие получаются находки и какие из них получаются готовые комментарии с подстановками.

В диалоге есть встроенная справка, доступная по команде `?`. Вот ее содержимое
```
Shell commands:
  q             Exit
  ?             Help
  s name        Stash main data (p,n,t) with the name
  u name        Fill main data by stashed values with the name
  u?            Show stashed items
  ol=[0/1/2/3]  Set log level (now is 0, default is 0)
  ow=[num]      Set width for pretty format of hits/cmnts (now is 120, default is 120)
Set main data:
  p=...         Set sugared skill-pattern
  n=...         Set skill-note
  t=...         Set text for seaching
Trick values after = to work with multyline texts:
    _    to paste-from-clipboard
    ^    to copy-to-clipboard
Auto-data:
  r:            re-pattern
  hits:         Found fragments for skill-pattern and text
  cmnts:        Ready comments for skill-pattern, skill-note, text
Sugars for skill-patterns:
  ■ □ ▪ ▫       In row: chars>0 chars≥0 spaces>0 spaces≥0
  ○             Blanks≥0
  ‡ (‡) [‡] {‡} Fillers: min from-to, to paired bracket
  ◊             Skipper "same shifts≥0"
  ‡‡            SubID≥0             
  †             ' or "
  ► ▲ ◄         Variants
  ↓1            Store row number to use {{_.↓1}} in skill-note
  ≤name≡X≥      Store named fragment
  ╣X╣ ╠X╠ ╔X╗   Banned text near founded: after, before, between
  « »           Ready re-code
```

Пример применения АР-шелла.  
Задан шаблон `▫«\d+»↓1▫`, задан note как `x {{hits._.txt}} y (at {{_.↓1}})`, задан многострочный текст для поиска.
Шелл показывает пять находок и пять готовых комментариев.
```
  p: ▫«\d+»↓1▫
  r:  *\d+(?P<_rOw_1>(?<!↓)) *
  n: x {{hits._.txt}} y (at {{_.↓1}})
  t:
xy 123 zz 231
zz 4 qw
qw 56 we we 789 er
  hits:
[{'btm': 1, 'top': 1, 'top__rOw_1': 1, 'txt': ' 123 '},
 {'btm': 1, 'top': 1, 'top__rOw_1': 1, 'txt': ' 231'},
 {'btm': 2, 'top': 2, 'top__rOw_1': 2, 'txt': ' 4 '},
 {'btm': 3, 'top': 3, 'top__rOw_1': 3, 'txt': ' 56 '},
 {'btm': 3, 'top': 3, 'top__rOw_1': 3, 'txt': ' 789 '}]
  cmnts:
[OneRV.Cmnt(row=1, lev='E', txt='x  123  y (at 1)'),
 OneRV.Cmnt(row=1, lev='E', txt='x  231 y (at 1)'),
 OneRV.Cmnt(row=2, lev='E', txt='x  4  y (at 2)'),
 OneRV.Cmnt(row=3, lev='E', txt='x  56  y (at 3)'),
 OneRV.Cmnt(row=3, lev='E', txt='x  789  y (at 3)')]

? q ■□▪▫○◊‡†►▲◄↓≤≡≥«» >>> 
```
В приглашении (нижняя строка) шелл всегда показывает сахарные знаки.


## Монитор для автоматического запуска АР <a name=monitor></a>  
При запуске (cм [обзор](#monitor-use))

    `py10 autorv2.py -m папка-с-именами-студентов`

АР2 переходит в режим подобный демону/сервису, при котором АР-Монитор наблюдает за указанной папкой и папками вложенными в нее.  
Останавливается Монитор через `Ctrl+C`.

Монитор отслеживает:
- Создание ревьювером новой подпапки (добавился студент). 
- Появление в подпапке нового zip (ревьювер скачал новую домашку).

Действия при появлении нового zip регулируются через настройку `opts.monitor.acts`.  
Умолчательный набор действий уже зашит в код АР. Он включает:
- **Запуск АР** для создания zip-для-Ревизора на первых двух итерациях.  
**Писки** в конце шага (опционно).  
Писк полезен, так как АР2 будет работать "за кадром" неопределенно долго.  
Первый писк  
    либо высокий - "удача, можно грузить в Ревизор",  
    либо низкий - "провал".  
Второй писк (еще выше) будет, если заказано копирование в клип пути к созданному зип-файлу.

- **Распаковка** zip-а.  
Этот шаг подготавливает папку для сравнения. Если сравнение не настроено, то и распаковка пропускается.  
Монитор выяснит какой у домашки главный ключ (snk, b1, ...) и будет выполнять распаковки в папки вида  
    snk_1,  
    snk_2,  
добавляя номер итерации.  
Номер последней итерации хранится в файле `ar2mon.json`. Его можно менять вручную.  
Распаковываются не все элементы - Монитор пропускает имена, перечисленные в `opts.commom_skiped_inpaths`.  
- **Запуск** сравнивающей две папки-с-итерациями утилиты (типа WinMerge).  
Настройка команды в списке по ключу `opts.monitor.diff_cmd`.  
В любом элементе списка можно указывать подстановки 
    `{{WRK}}` папка `путь/ключ-итерация`, где распакован zip,
    `{{PRV}}` папка `путь/ключ-итерация`, где распакован zip от предыдущей версии,.  
    `{{WRK/1ST}}` папка `путь/ключ-итерация/первая-папка`, где распакован zip,
    `{{PRV/1ST}}` папка `путь/ключ-итерация/первая-папка`, где распакован zip от предыдущей версии,.  
Например, настройка для запуска WinMerge может иметь вид  
    `diff_cmd=['d:/Programs/WinMerge/WinMergeU.exe', '/r', '{{WRK}}', '{{PRV}}'],`  

   Монитор будет запускать еще и сравнение  
    первой итерации новой домашки  
с  
    последней итерацей от предыдущей домашки,  
если домашки входят в серию. См настройки `opts.monitor.prev_hwkeys`.

### Горячие замены и перезапуски
- Монитор будет отлеживать обновления АР-файлов, указанных в ветках `opts.skills.ключ.skills`.  
Будут применяться свежие.
- Если в ключе `opts.monitor.force_update_ext_tools_if_any_changed` перечислить файлы, то их изменение приведет к 
сбросу кэша у плаг-сахаров.  
Пока это применимо к espanso через например такую настройку  
    `force_update_ext_tools_if_any_changed=['путь/espanso/default.yml'],`.

При изменениях в зашитых или личных (`autorv2.cfg.py`?) настройках АР требуется перезапуск Монитора.  
При добавлении новых АР-файлов требуется перезапуск Монитора.


## Демонстрация XML для кода из произвольного файла <a name=py2xml></a>  
При запуске

    `python autorv2.py -ax путь-файла.py`

будет создан файл `путь-файла.py.xml`, содержащий XML-дерево построенное из AST-дерева этого кода.



# Брифы


## Шпаргалка "минимальный набор новичка"<a name=min_brief></a>  

**Сахара**

| Обозначение        | Назначение         | Комментарий/Пример  |
| --                 | --                 | --           |
|                    | **Изоляторы**      | |
| `«шаблон»`<br>`<!<шаблон>!>`         | Готовая регулярка  | `def «[ab][xy]»(‡):`<br>     функции с именами ax/bx/ay/by |
|                    | **Пропускаторы** | |
| `□` `■`            | Любые (≥0) (>0) символы внутри строки | Удобно для пропуска хвоста строки |
| `▫` `▪`            | Пробелы (≥0) (>0) | |
| `○`                | Пробельные символы (≥0) | |
| `‡`                | Минимальный "заполнитель между" <br>из любых (≥0) символов, включая концы строк | Стяжка |
| `(‡)` `[‡]` `{‡}`  | Заполнитель "до парной скобки" | Глубина вложенности \<3|
| `◊`                | Пропуск минимального набора (≥0) <br>строк с таким же отступом | Удобно пропускать часть кода внутри одной функции |
|                    | **Извлекаторы**    | |
| `‡‡`               | Часть (≥0) идентификатора с точками  |  |
| `†`                | Одна из кавычек    | |
| `►` `▲` `◄`        | Выбор из вариантов | Ожидаются до 10 вариантов.<br>Пример: `►0▲2▲4▲6▲8◄` |
| `↓1` <br>`↓2`      | Запоминание номера строки исходника | Вставляется в `note` как <br>     `{{_.↓1}}` `{{_0.↓1}}` <br>     `{{_.↓2}}` `{{_0.↓2}}` <br>Вставляется в `formula`/`position` как <br>     `_.↓1` `_0.↓1` <br>     `_.↓2` `_0.↓2` |
| `≤name≡XX≥`        | Именованная группа | `def ≤fn≡‡‡≥(‡)` <br> Вставляется в `note` как <br>     `{{hits._.txt_fn}}` <br> Вставляется в `formula`/`position` как <br>     `hits._.top_fn` |
|                    | **Условия на извлечение** | |
| `╣XX╣`             | Лишний текст **после** найденного | `подходит, если дальше нет╣ этой части╣` |
| `╠XX╠`             | Лишний текст **перед** найденным | `╠без этой части ╠подходит` |
| `╔XX╗`             | Лишний текст **между** найденными | `подходит ╔без этой части╗ фраза` |

**АР-словарь**.

| Ключ<br>(!)=обязательный | Варианты значений  | Назначение               | Комментарий/Примеры   |
| --                    | --                    | --                       | --                    |
| [level](#levl) (!)    | `'E'`<br>`'F'`<br>`'G'` | **E**rror=Ошибка<br>**F**ail=Совет<br>**G**ood=Похвала     |                       | 
| [pattern](#pttn) (!)  | `'...'`               | Искать по одному шаблону  | Внутри `note` как `{{hits._.txt}}`, <br>внутри `formula`/`position` как `hits._.top` | 
|                       | `['...', '...']`      | Искать по одному из шаблонов | Внутри `note` как `{{hits._0.txt}}`, <br>внутри `formula`/`position` как `hits._0.btm` |
|                       | `{'p1':'...'}`        | Искать по одному из шаблонов | `{{hits.p1.txt}}` <br> `hits.p1.top`         | 
| [note](#note) (!)     | `'...'`<br>`['...', '...']`<br>`{'n1':'...'}`  | Что написать <br>к первой находке, <br>второй и тд     |                       |
| [repeats](#rpts)      | `'as-note'`<br>`'one'`<br>`'all'`<br>`3`     | Повторять поиски  | авто: `'as-note'` - *не более чем вариантов в note*.<br>Если в note мало и нужно больше, то повторяется последний из note |
| [formula](#frml)      | `'...'`               | Ручной анализ на успех   | авто: *есть хоть одна находка* <br>Примеры:<br>     `'"abc" in hits._.txt'`<br>     `'hits._0 and not hits._1'` |
| [position](#posi)     | `'...'`               | Ручной выбор места       | авто: *нижняя строка от всех находок* (промахи дают -1) <br>Пример:<br>     `'min(hits._0.top+1, hits._1.btm-1)'` |


## Миграция с АР1<a name=migrate></a>  
<details><summary>Подробности</summary>  

1. Сахара
   - Замены:  
       `¬°` стал `◊`,  
       `!<` `¦` `>!` стали `►` `▲` `◄`,  
       `╠` `╣` стали `╠` `╠`,  
       Внутри `note` вместо `↓1` применяется `{{_.↓1}}` или `{{_0.↓1}}`.  
   - Удалены синонимы (легко восстанавливаются в личной версии):  
       из `▪` и `¶±` остался только `▪`,  
       из `□` и `▬` остался только `□`,  
       из `▫` и `…` остался только `▫`,  
1. АР-словари
   - Замены имен ключей:  
       `levl` на `level`  
       `pttn` на `pattern`  
       `frml` на `formula`  
       `posi` на `position`  
       `rpts` на `repeats`
       `pttn_wo_strip` на `wo_strip`
   - Формулы внутри `frml`/`posi` применяли  
       `m_0`/`m_1`    
       `p_0`/`p_1`.  
   Формулы внутри `formula`/`position` применяют для тех же целей  
       `hits._0`/`hits._1`  
       `hits._0.btm`/`hits._1.btm`.  
1. АР-файлы
   - Ключи к наборам АР-словарей в АР-1 были именами или кортежами имен путей файлов.  
В АР2 это всегда одна регулярка на пути файлов.  
Поэтому для не-кортежей есть прямое наследовние, а для кортежей требуется ручная переделка.
   - Ключ `'end_sign':подпись`.  
В АР1 ожидался в корневом словаре АР-файла.  
А в АР2 он ожидается в спец-словаре  
    `'defaults': dict(..., 'end_sign':подпись, ...),`
1. Сборка АР-файлов.  
   - Больше не нужны многочисленные указания папок  
       `> django_sprint1-main/blogicum/`  
       `> django_sprint1/blogicum/`  
   Поиск общей папки автоматизирован.
   - Фильтр  
       `? $rv.levl=="E"`  
   стал записываться в формате  
       `{ard.level=="E"}`  
1. Применение `espanso` не изменилось.  
А настройка переместилась из  
    `opts.ready_notes.espanso`  
в  
    `opts.ext_tools.espanso_cli`.

</details>

## AST-дерево и его XML-представление <a name=ast_xml_brief></a>  
<details><summary>Подробности</summary>  

[Оф-док](https://docs.python.org/3/library/ast.html)
1. Структура дерева
    - Корнем дерева всегда будет узел типа `Module`.
    - Кроме модуля **крупными ветками** дерева станут классы и функции/методы.
    - Крупные ветки могут содержать список из узлов  
       - `Import`/`ImportFrom`
       - `AnnAssign`/`Assign` - присвоение (хинтовой) переменной(ым)
       - `AugAssign` - присвоение с операцией над переменной
       - `Raise`/`Assert`/`Pass`/`Break`/`Continue`/`Return`/`Yield`/`YieldFrom`
       - `If`/`For`/`While`/`Try`/`With`/`Match`
       - `FunctionDef`/`ClassDef`
    - `FunctionDef` содержит 
       - `decorator_list` список из `Name`
       - `name` обязательный текстовый атрибут
       - `args` параметры в виде класса `arguments` с элементами `args` и `kwarg`
       - `body` список узов для крупного узла.
    - `ClassDef` содержит 
       - `decorator_list` список из `Name`
       - `name` обязательный текстовый атрибут
       - `bases` список из `Name`
       - `body` список узов для крупного узла.
1. Представления некоторых узлов  

   Литералы  
`123` как `Constant(value=123)`  
`'abc'` как `Constant(value='abc')`  

   Составные примитивы  
`[123,'abc']` как `List(elts=[Constant(value=123), Constant(value='abc')])`  
`{'abc':123}` как `Dict(keys=[Constant(value='abc')], values=[Constant(value=123)])`  
  
   Генераторный список `[x for x in ns]` как  
   ```python
   ListComp(
     elt=Name(id='x'),
     generators=[comprehension(target=Name(id='x'), iter=Name(id='ns'))])
   ```
   
   Генераторный словарь `{x: x**2 for x in ns}` как  
   ```python
   DictComp(
     key=Name(id='x'),
     value=BinOp(left=Name(id='x'), op=Pow(), right=Constant(value=2)),
     generators=[comprehension(target=Name(id='x'), iter=Name(id='ns'))]))
   ```

   Объявление функции `def func(a, b=c, *d, **e):pass` как  
   ```python
   FunctionDef(name='func',
     args=arguments(
       args=[arg(arg='a'), arg(arg='b')],
       defaults=[Name(id='c')]),
       vararg=arg(arg='d'),
       kwarg=arg(arg='e'),
     body=[Pass()],
     decorator_list=[])
   ```

   Вызов функции `func(a, b=c, *d, **e)` как  
   ```python
   Call(func=Name(id='func'), 
        args=[Name(id='a'), Starred(value=Name(id='d'))], 
        keywords=[keyword(arg='b',value=Name(id='c')), keyword(value=Name(id='e'))])
   ```

   Объявление класса `class Foo(B1, B2):pass`
   ```python
   ClassDef(
     name='Foo',
     bases=[Name(id='B1', ctx=Load()), Name(id='B2', ctx=Load())],
     body=[
       Pass()],
     decorator_list=[])],
   ```

1. Замечания
   - В дереве не сохраняются комментарии!
   - У узлов модуль/класс/функция можно узнать док-строку.
   - У AST-узла через атрибуты  
       `lineno`, `col_offset`, `end_lineno`, `end_col_offset`  
можно узнать его локализацию внутри исходного текста.  
   - Увидеть AST-дерево для произвольного Питон-кода можно через  
       `import ast;print(ast.dump(ast.parse(код), indent=2))`

1. XML представления  
Для произвольного Питон-модуля можно увидеть его полный XML через [спец-запуск](#py2xml) АР2.

   Литералы  
`123` как  
   ```xml
   <Constant type="int" value="123"/>
   ```
   `'abc'` как  
   ```xml
   <Constant type="str" value="123"/>
   ```

   Составные примитивы  
`[123,'abc']` как  
   ```xml
   <List><elts>
     <Constant type="int" value="123"/>
     <Constant type="str" value="abc"/>
   </elts></List>
   ```

   `{'abc':123}` как  
   ```xml
   <Dict>
     <keys><Constant type="str" value="abc"/></keys>
     <values><Constant type="int" value="123"/></values>
   </Dict>
   ```

   Генераторый список `[x for x in ns]` как  
   ```xml
   <ListComp>
     <elt><Name id="x"/></elt>
     <generators>
       <comprehension>
         <target><Name id="x"/></target>
         <iter><Name id="ns"/></iter>
         <ifs/>
       </comprehension>
     </generators>
   </ListComp>
   ```

   Генераторный словарь `{x: x**2 for x in ns}` как  
   ```xml
   <DictComp>
     <key><Name id="x"/></key>
     <value>
       <BinOp>
         <left><Name id="x"/></left>
         <op><Pow/></op>
         <right><Constant type="int" value="2"/></right>
       </BinOp>
     </value>
     <generators>
       <comprehension>
         <target><Name id="x"/></target>
         <iter><Name id="ns"/></iter>
         <ifs/>
       </comprehension>
     </generators>
   </DictComp>
   ```

   Объявление функции `def func(a, b=c, *d, **e):pass` как  
   ```xml
   <FunctionDef name="func">
     <args>
       <arguments>
         <args><arg arg="a"/><arg arg="b"/></args>
         <defaults><Name id="c"></Name></defaults>
         <vararg><arg arg="d"/></vararg>
         <kwarg><arg arg="e"/></kwarg>
       </arguments>
     </args>
     <body><Pass/></body>
   </FunctionDef>
   ```

   Вызов функции `func(a, b=c, *d, **e)` как  
   ```xml
   <Call>
     <func><Name type="str" id="func"></Name></func>
     <args>
       <Name type="str" id="a"/>
       <Starred ><value><Name type="str" id="d"/></value></Starred>
     </args>
     <keywords>
       <keyword type="str" arg="b">
         <value><Name type="str" id="c"/></value>
       </keyword>
       <keyword><value><Name type="str" id="e"/></value></keyword>
     </keywords>
   </Call>
   ```

   Объявление класса `class Foo(B1, B2):pass`  
   ```xml
   <ClassDef name="Foo">
     <bases><Name id="B1"/><Name id="B2"/></bases>
     <body><Pass/></body>
     <decorator_list/>
   </ClassDef>
   ```
</details>

## Про XPath-язык <a name=xpath_brief></a>  
<details><summary>Подробности</summary>  

[Оф-док](https://docs.python.org/3/library/xml.etree.elementtree.html#supported-xpath-syntax)
1. Общий вид XPath-запроса на излечение узлов из XML  
    `тег/*/*[условие]//тег[@атрибут]/тег[../тег[@атрибут=123]]//тег[@атрибут!='y']]/тег[2]/*[2]/*[last()]`  
где  
   - `/*` все вложенные узлы,
   - `[условие]` может рекурсивно содержать извлечения узлов с условиями,
   - `//тег` спуск на произвольную глубину до всех `тег`ов,
   - `тег[@атрибут]` все `тег`и с таким `атрибут`ом (любое его значение),
   - `тег[@атрибут=123]` все `тег`и с таким значением `атрибут`а,
   - `тег[@атрибут!='y']` все `тег`и с другим значением `атрибут`а,
   - `тег/../брат` соседний `брат`, то есть дочерний у предка `тег`,
   - `/тег[2]` **второй** (не третий) из `тег`ов,
   - `/*[2]` **второй** из всех,
   - `/*[last()]` последний из всех.
1. В этом языке нет логических операторов.  
Но можно трюком получить AND, если несколько раз заходить в уникальный узел через родителя.  
Пример. Поиск  
    `тег[@атрибут1]/../тег[@атрибут2=2]/../тег[@атрибут3!='y']`  
найдет `тег`, если у него выполнятся все три условия на аттрибуты.
1. Примеры для поисков от корня AST-XML-дерева  
   - `//ClassDef[@name='Post']//ClassDef[@name='Meta']`  
   Извлечение класса Post.Meta.
   - `//ClassDef[@name='Post']//Assign[targets/Name[@id='title]]//Call//keyword[@arg='verbose_name']`  
   Извлечение для класса `Post` из поля `title` параметра `verbose_name`.  
   Логика поиска:  
   – Из всех классов нужен с имеем `Post`.  
   – Из всех присвоений внутри класса (=объявлений полей) нужно с левой частью `title`.  
   – В провой части присвоения внутри вызова (конструктор) нужен ключевой параметр `verbose_name`.  
   При записи в виде  
       `//*[@name='Post']//*[targets/Name[@id='title]]//keyword[@arg='verbose_name']`  
   получается такой же поиск, лишь менее эффективный.

</details>



# Известные проблемы
- Ревизор глотает начальные пробелы в комментах.  
Поэтому АР меняет левый пробел на символ `·`.  
В результате примеры кодов/разметки в комментах оказываются некорректными.  
Ждем исправления Ревизора.



# (ToDo) В планах
<details><summary>Подробности</summary>  

- Добавить элементы AST-флагов в знания: указывать "в комментарии" или "внутри строкового литерала".
- Добавить в разделе Техн.Детали ссылки на применения из раздела Готовые решения.
- Избавиться от путанициы терминов сахарная зона и зона без экранирований.
- Перевести все примеры на Змейку?
- В брифы добавить пример работы с WinMerge.
- Создать веб-сервер для тестирования поисков

</details>



# Зависимости и заимствования
Платформа
- Python 3.10+

Зависимости
- [pytest](pytest.org) для внутренних тестов.
- [PyYAML](pyyaml.org) для работы с YAML.
- [parso](https://parso.readthedocs.org/en/latest/) для работы с AST.
- [lxml](https://lxml.de/) для работы с XML.
- (позже) [cssselect](https://github.com/scrapy/cssselect) для работы с CSS3 selectors.
- [pyperclip](https://github.com/asweigart/pyperclip) для АР-шелла - вставлять многострочные тексты.
- [watchdog](https://github.com/gorakhargosh/watchdog) для сигналов о появлении зипов для Монитора.

Заимствования
- Конвертация AST-дерева в XML из [pyastgrep](https://github.com/spookylukey/pyastgrep)
- Регулярка для поиска парной скобки от codengineering.ru (уже умер).

Применяется, если установлена и есть на нее [настройка](#espanso), ОС-утилита
- [espanso.org](https://espanso.org/) для автозамен текста.



# Благодарности
- Денис Унтевский.  
За соавторство.
- Игорь Шкода, Виталий Чернышов.  
За плодотворные обсуждения ТЗ.
- Артем Коломацкий.  
За полезную критику и за идеи для работы с AST-деревом.
- Максим Любиев.  
За идею с веб-сервером.
- Алексей Потапов.  
За фронт для Фласк-сервера. 
- Яков Варнаев.  
За идею полуфабриката знаний.  
- Андрей Дубинчик, Яков Варнаев, Игорь Шкода, Максим Любиев, Андрей Тюрин.  
За участие в тестировании.



# История обновлений <a name=hist></a>
- 2.0.100 29feb24
   - [+] Старт разработки
- 2.0.101 19apr24
   - [+] Согласованное ТЗ в виде Readme
   - [+] Покрытие сахаров тестами
- 2.1.100 25jul24 beta
   - [+] Полуфабрикат для чеков Змейки: поиски есть, замечания нужно заменять.
- 2.1.201 07aug24 beta
   - [+] АР-шелл для конвертирования сахаров в регулярки и простейших поисков и комментариев по находкам.
   - [+] Словарь `opts.defaults` для глобального изменения умолчаний в АР-словарях.
   - [+] Опция `-d` для изменения набора умолчаний `opts.defaults`.
   - [+] Словарь `opts.context` для глобальных констант, доступных в подстановках для `pattern`/`note`/`formula`/`position`.
   - [+] Опция `-c` для изменения набора глобальных констант `opts.context`.
   - [+] После задания в АР-словаре ключа `name=имя`, его комментарии (место и текст) и находки (верхняя/нижняя строка, текст), которые для них применяли, доступны в других АР-словарях через
      - `имя.номер.row` `имя.номер.txt` `имя.номер.hits._.btm` `имя.номер.hits._.txt`
- 2.2.001 11aug24 beta
   - [+] АР-монитор для автоматического создания зип-для-Ревизора.
- 2.2.002 15aug24 beta
   - [*] Изменилась запись пути по дереву настроек при использовании опции `-o` при запуске.
      - Было: `-o skill/snk/skill/0=...`
      - Стало: `-o skill.snk.skill._0=...`
      - Цель: однообразие форматов. Теперь формат прохода по json-дереву одинаковый при запуске и в АР-словарях.
   - [*] Изменился доступ к уже сделанным комментариям из АР-словаря с ключом `name=имя` в других АР-словарях.
      - Было:    `имя.номер.row`   `имя.номер.txt`   `имя.номер.hits._.btm`   `имя.номер.hits._.txt`
      - Стало: `имя._номер.row` `имя._номер.txt` `имя._номер.hits._.btm` `имя._номер.hits._.txt`
- 2.2.003 01sep24 beta
   - [+] Добавлена фильтрация АР-словарей при [сборке](#build) знаний из нескольких АР-файлов.
- 2.2.004 02sep24 beta
   - [+] Заработали вставки `↓1` при извлечении комментария через [эспансу](#espanso).
   - [*] Имя константы с итераций от Монитора стало `ITER` (было `MON_ITER`).
   - [*] Константа `ITER` стала встроенной (с умолчанием `0`).
- 2.3.001 29sep24 
   - [*] Исправлена ошибка применения `«»` в многострочном `pattern`.
   - [+] Добавлено логгирование шаблона при сбое поиска по `pattern`.
