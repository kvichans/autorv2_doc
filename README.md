# Цель
Консольная утилита, преобразующая архив с ДЗ в новый архив, 
который Ревизор готов принять и перенести из него комментарии в исходные файлы домашки.



# Способ применения
Минимальный полезный запуск
```
python autorv2.py путь-к-домашке.zip
```
создаст (перезапишет!) файл `путь-к-домашке.fN!F+G-E.zip`, который можно передать Ревизору.  
Вместо `N`, `F`, `G`, `E` будут подставлены числа, отражающие результат работы:  
    `N` - число файлов, в которые попали комменты,  
    `F` - число неточностей (**Можно лучше**),  
    `G` - число удач (**Отлично**),  
    `E` - число ошибок (**Надо исправить**).



# Основные идеи


## (1) Ревьювер сохраняет свои навыки в "приватных знаниях"

1. Настройки знаний размещаются в **приватных** json-подобных файлах.  
Для одной домашки собираются знания из нескольких файлов.  
Например, можно выносить претензии к нарушениям языка/РЕР8 в файл, который подхватывать для всех домашек.  
Например, можно для серии домашек подхватывать файл от предыдущей домашки.  
2. Порядок сборки файлов знаний указывается в **публичных** или **приватных** настройках АР.  
Такие настройки (точнее их умолчательный вариант) публикуются вместе с исполняемым кодом.


## (2) Способы поиска
У ревьювера есть несколько подходов для организации поиска мест, требующих комментирования.

1. Можно писать только Питон-регулярки.  
    (+) Не потребуется переучиваться.  
    (+) Не потребуются символы, которых нет на клавиатуре.  
    (-) Будут появляться громоздкие и/или малопонятные конкструкции.  
    Например, регулярка, захватывающая до парной фигурной скобки,   
    `\{[^\{\}]*?(?:\{[^\{\}]*?(?:\{[^\{\}]*?\}[^\{\}]*?)*?\}[^\{\}]*?)*?\}`.  
    (-) Обязательно выполнять экранирование точек, скобок, обратных слешей и прочих re-символов,  
    если они есть в искомом фрагменте.  
1. Чтобы избегать громоздкости и экранирований, АР предлагает применять сахара.  
    **Сахар - часть поисковой разметки, которая позже станет регуляркой.**  
Сахара специально записываются символами, которые точно не встречаются в re-языке 
(и еще вряд ли встретяться в исходниках).
1. Сахар может быть совсем примитивным:  
    `■` подменяется на `.+` и позволяет захватывать любые символы в текущей строке.  
Сахар может скрывать простое, всего лишь громоздкое re-выражение:  
    `{‡}` дает захват до парной фигурной скобки.  
Но сахарые подмены могут через АР достигать и более сложных целей.  
Они могут захватывать окрущающие символы, чтобы конечная регулярка их учитывала:  
    `¬°` позволяет построить поиск нескольких подряд строк с таким же отступом.  
    `╠фраза╣...` позволяет построить поиск фрагмента без указанной фразы перед `...`.  
Есть еще более продвинутые сахара.  
    `↓1` позволяет АР запоминать номер строки исходника, где встретился такой сахар.  
    Позже этот номер можно будет вставить в комментарий или использовать в логике.  
1. Вставить сахар можно несколькими способами:
   - Через недоступный с клавиатуры **символ**, такой как `■`.  
   - Через указания Юникод-номера: в hex-формате `'0x25a0'` (но зачем?).   
   - Через указания **Юникод-имени** внутри штатной конкструкции: `'\N{BLACK SQUARE}'`.  
У *всех* символов есть такие имена - их можно узнать через `unicodedata.name('■')`.  
   - Через указания **АР-имени** внутри конструкции `~{ANY_IN_ROW}~`.  
У всех сахаров есть такие имена. В том числе у каждого куска для составных, таких как `╠...╣...`.  
1. АР предоставляет возможность внутри одного поискового шаблона иметь зоны "чистых регулярок" и "сахарной разметки".  
Для этого такие зоны-**изоляторы** указываются внутри лапок `«...»`.  
Внутри изоляторов могут быть "чистые регулярки" (по умолчанию), либо сахара.  
Как АР будет обрабатывать весь шаблон и/или каждый изолятор, настраивается:  
   - По умолчанию АР считает весь шаблон сахарным, а внутри изоляторов видит регулярки.  
   - Настройкой для одного поиска или для одного файла знаний или для всех поисков можно переключить АР 
на ожидание регулярок и сахарные изоляторы.


## (3) Минимальным элементом "знаний" является АР-словарь
Цель такого [АР-словаря](#rv-dict) - указать для одной претензии "что найти" и "как прокомментировать".  
**Пример.** АР-словарь
```python
dict(
    level='F', 
    patten='kwargs↓1={'‡‡': ┌‡┬key┐}',
    note='+t:Рекомендую в строке ↓1↓ заменить `{{patten_rt.g}}` на `args=[{{patten_rt.g.key}}]`.',
)
```
указывает, что нужно искать выражения вида  
    `kwargs={'идентификатор': любой-код-без-фигурной-скобки}`  
На поиск "идентификатора" указывает `‡‡`.  
На поиск "любой-код-без-фигурной-скобки" указывает `‡...}`.  
При поисках каждый раз  
    запоминать номер строки (по `↓1`),  
    давать подфрагменту имя `key` (по `┌подфрагмент┬key┐`).  
Если в исходнике в строках 123..126 есть код  
```python
123   ... = reverse(
124       'new:edit', 
125       kwargs={'id': post_id}
126   )
```  
то АР добавит комментарий к строке 125  
```python
123   ... = reverse(
124       'new:edit', 
125       kwargs={'id': post_id}
      Рекомендую в строке 125 заменить kwargs={'id': post_id} на args=[post_id].
         Можно лучше
126   )
```  
Подстановка номера строки (по `↓1↓`) выполнится в любом случае.  
На подстановки фрагмента (по `{{patten_rt.g}}`) и подфрагмента (по `{{patten_rt.g.key}}`) указывает `+t:`.  

    
## (3) Поиски выполняются шаблонами с сахарной разметкой и/или регулярками

- Шаблон для поиска состоит из "сахара" и/или "натура" (=питон-регулярок).  
Сахарная часть [преобразуется](#do-sugar) в регулярки перед поиском.  
- Разделение на сахар и натур зависит от [ключа](#wait_re) `wait_re` в АР-словаре.  
При его умолчательном значении сахар ожидается как есть, а натур [внутри](#isolator) `«...»`.  
Можно поменять ожидания на обратные.  
- Сахарные знаки делятся на
   - [Зашитые](#in-sugar) в код АР: `«` `»` `‡` `↓` `╠` `╣` `¬°` `!<` `¦` `>!` `┌` `┬` `┐`.  
   Они задействованы в собственных алгоритмах АР.  
   - [Свободно](#free-sugar) заменяемые/дополняемые: `‡‡` `□` `▬` `■` `○` `¶` `▪` `…` `▫` `†`.  
   Каждый из них подменяется на фиксированную регулярку.  
   Такие знаки и их подмены перечислены в файле `autorv2_free_sugars.py`.  

**Примеры.**  

1. Шаблон `‡‡(‡)` ищет `идентификатор(любой-текст-ДО-ПАРНОЙ-закрывающей-круглой-скобки)`.  

1. Шаблон `!<так¦и так¦и эдак>!` ищет один из указанных фрагментов.  
Фрагменты сами могут быть с сахаром/натуром, но только без знаков `!<` `¦` `>!`.

1. Шаблон `(‡╠exc_info=True╣)` ищет случай, когда *перед* закрывающей скобкой нет `exc_info=True`.    

1. Шаблон `‡‡«[123]»` ищет идентификатор, заканчивающийся на одну из цифр 1, 2, 3.  



# Готовые решения

## Порядок применения АР2 руками <a name=hand-use></a>

1. Подготовить хотя бы один файл-знаний.  
АР2 по умолчанию ищет знания в своей подпапке `skills`.  
Например, можно создать файл `skills/skill_of_python.py` с таким наполнением  
   ```python
   {
     '*.py':[
       dict(level='E', wo_strip='T', repeats='all'
            patten='\\\n', 
            note=['Так низяяяяя! Заключайте в скобки.','Смотри выше',],
       ),
     ],
   }
   ```
1. Указать в АР2-настройках этот файл для проверяемой домашки.  
Например, если это ДЗ Бот, то в файле `def_opts.py` в ветке `skills` нужно показать созданный файл знаний:  
   ```python
       ...
       skills=d(
           bot=d(
               main_dirs_in_zip=['homework_bot-master', 'bot-master',],
               skills=['skills/skill_of_python.py',], # <<<<<<<<<<<<<<<<
           ),
       ),
       ...
   ```
   Этот шаг можно заменить на опцию при вызове - см ниже.
1. В Ревизоре на вкладке Ревью нажать верхнюю кнопку "скачать код" 
![image](https://github.com/kvichans/autorv2/assets/7419630/f335e978-adc0-4c7b-998f-05f0619973af) 
или нижнюю ссылку "Скачать код"  
![image](https://github.com/kvichans/autorv2/assets/7419630/99e886c1-b4ad-4d5d-8a62-5426055a1145)
1. Сохранить zip-файл в подходящей папке.  
1. Запустить АР2 в консоли через  
   ```bash
   > python autorv2.py путь-к-домашке.zip
   ```
   Можно вместо правки настроек прямо тут указать файл знаний  
   ```bash
   > python autorv2.py путь-к-домашке.zip -o "skills/bot/skills=['skills/skill_of_python.py']"
   ```
   Рядом с `путь-к-домашке.zip` будет создан файл с комментариями вида `путь-к-домашке.f1!1+0-0.zip`.  
1. В Ревизоре нажать на кнопку  
![image](https://github.com/kvichans/autorv2/assets/7419630/5e2ef660-92f0-4c5e-b1e5-dd8f5902543a)  
и выбрать созданный файл `путь-к-домашке.f1!1+0-0.zip`.


## Порядок применения АР2-Монитора <a name=monitor-use></a>

1. Подготовить файл-знаний `знания.py` (например, как в [ручном запуске](#hand-use)).
1. Указать эти знания в АР2-настройках для каждой конкретной домашки. Например, для Бота
   ```python
       ...
       skills=d(
           bot=d(
               main_dirs_in_zip=['homework_bot-master', 'bot-master',],
               skills=['skills/знания.py',], # <<<<<<<<<<<<<<<<
           ),
       ),
       ...
   ```
1. Один раз запустить Монитор в консоли/демоне/сервисе  
   ```bash
   > python autorv2.py -m папка-всех-студентов
   ```
   При доработках в `знания.py` Монитор перезапускать не нужно - он сам подхватит изменения.  
При доработках АР2-настроек перезапуск нужен.
1. Теперь можно сохранять из Ревизора zip-файл с домашкой в  
    `папка-всех-студентов`  
или в  
    `папка-всех-студентов/студент`  
    NB! Монитор не создает подпапку `студент` - это ручная работа для ревьювера.  
Монитор  
    отследит появление zip,  
    запустит АР2.  
Для ревьювера это будет выглядеть так, будто **zip-файл с комментариями появится сам**.  
Останется подхватить его в Ревизоре так же, как при [ручном запуске](#hand-use).  
1. Если Монитор настроен с запуском дифф-тула, то после сохранения zip в папку  
    `папка-всех-студентов/студент`  
Монитор распакует его в новую подпапку - ее имя сформируется из главной папки в zip и номера итерации.  
Например, для Бота это будут папки  
    `папка-всех-студентов/студент/homework_bot-master_1`,  
    `папка-всех-студентов/студент/homework_bot-master_2` и тд.  
Монитор запустит дифф-тул, чтобы показать разницу последней и предыдущей итераций.

## Заготовки для типовых ситуаций

### Применение \ для продолжений кода
**АР-словарь**:
```python
dict(level='E', wo_strip='T', repeats='all',
    patten='↓1\\\n',
    note=['Так низяяяяя! В скобки их!', 'Смотри коммент к строке ↓1↓.',],
),
```
*Пояснения.*  
– `wo_strip='T'` - не удалять пробельные символы из `patten`.  
– `repeats='all'` - комментировать все случаи.  
– `↓1` - запомнить номер строки с первым найденным случаем.  
– `↓1↓` - вставить номер запомненной строки.  
**Размещение**: в файле знаний для проверки Питона  
```python
{
'*.py':[тут],
}
```
**Реакции**:  
– Первый случай в каждом модуле будет с описанием проблемы и советом.  
– Остальные случаи в каждом модуле будут ссылками на совет.  

### Нарушение порядка импортов
Поиск случаев, когда импорты установленных либ идут позже импортов из проекта.  
**АР-словарь**:  
```python
dict(level='E', 
    patten=['''
from !<.¦post¦blog¦app>!■○
from !<django¦rest¦flask¦fast>!
''',], 
    note='А как же РЕР8? Учили вас, учили...',
),
```
*Пояснения.*  
– `!<.¦post¦blog¦app>!` - поиск одного из указанных простых фрагментов.  
– `■` - любые символы в пределах этой же строки.  
– `○` - любые пробельные символы, например, пустые разделяющие строки.  
**Реакции**:  
– В каждом модуле один раз указывается на недостаток в импортах.  

### Нарушение 2-сдвигов в шаблонах
(*В разработке*)
### Неуместные print() в рабочих модулях
(*В разработке*)
### Нарушенный порядок поле-Meta-метод в модели
**Размещение**: в файле знаний для проверки проектов с моделями  
```python
{
'defaults': dict(level='E', repeats='all',),
'.*models.py':[тут],
}
```
**АР-словари**:  
```python
dict( 
    patten=['''
class ■
    ¬°
    def ↓2■
    ¬°
    class Meta↓1■
''',], 
    note=['Не ложьте Мета за методы (см с.↓2↓)!', ' См выше (строка ↓1↓).'],
),
dict( 
    patten=['''
class ■
    ¬°
    class Meta■
    ¬°
    ‡‡ = ↓1■
''',], 
    note=['Не ложьте Мета перед полями!', ' См выше (строка ↓1↓).'],
),
dict( 
    patten=['''
class ■
    ¬°
    def ↓2■
    ¬°
    ‡‡ = ↓1■
''',], 
    note=['Не класьте поля за методы (см с.↓2↓)!', ' См выше (строка ↓1↓).'],
),
```
*Пояснения.*  
– `'defaults': dict(level='E', repeats='all',)` - общее задание ключей `level` и `repeats` для всех АР-словарей.  
– `■` - любые символы в пределах этой же строки.  
– `¬°` - любое количество (в тч нулевое) строк с таким же отступом (тут - 4 пробела).  
– `‡‡` - идентификатор, т.е. словов из букво-цифр-_-точки. `‡‡ = ` ловит имя поля.  
– `↓1` - запомнить номер строки с первым найденным случаем.  
– `↓1↓` - вставить номер запомненной строки.  
**Реакции**:  
– В модуле с моделями указывается на все неудачные взаимные размещения полей/Meta/методов.  
Первый раз подробно. Остальные ссылкой на первый. 

### Не хватает локализации модели
Поиск случаев, когда в Meta у модели нет переводов.  
**Логика поисков**  
    Если не найден `verbose_name` внутри `Meta`,  
    но найден сам `Meta` или класс, где он должен быть,  
    то нужен комментарий у `Meta` или хотя бы у класса.  

**Размещение**: в файле знаний для проверки проектов с моделями  
```python
{
'.*models.py':[тут],
}
```
**АР-словари**:  
  
Ловим случай, когда `Post.Meta.verbose_name` в моделях нет, но `Post.Meta` или `Post` есть.  
Варианты шаблонов заданы списком  
```python
dict(level='E', 
    patten=['''
class Post■
    ¬°
    class Meta:‡
        ¬°
        verbose_name =''','''
class Post■
    ¬°
    class Meta''','''
class Post''',
],
    note='Когда ж локализации-то будут?',
    formula='not {{patten_rt._0}} and ({{patten_rt._1}} or {{patten_rt._2}})', 
    position='max({{patten_rt._1.btm}}, {{patten_rt._2.btm}})',
),
``` 
*Пояснения.*  
– `■` - любые символы в пределах этой же строки.  
– `¬°` - любое количество (в тч нулевое) строк с таким же отступом (тут - 4/8 пробелов).  
– `formula='...'` - текст формулы, которая после eval() скажет "успешен ли поиск".  
– `position='...'` - текст формулы, которая после eval() скажет "номер строки, куда коммент вставлять".  
– `{{patten_rt._0}}` инфа про результат поиска первым шаблоном из списка.  
– Вычисление `not {{patten_rt._0}}` будет давать Да, если поиск провалился (инфа пустая).  
– `{{patten_rt._1.btm}}` - номер последней строки для найденного фрагмента (тут второго).  
– Вычисление `max({{patten_rt._1.btm}}, {{patten_rt._2.btm}})` даст нижнюю строку от одного из найденных фрагментов.
  
Ловим случай, когда `Comment.Meta.verbose_name` в моделях нет, но `Comment.Meta` или `Comment` есть.  
Варианты шаблонов заданы словарем  
```python
dict(level='E', 
    patten=dict(clss_good='''
class Comment■
    ¬°
    class Meta:‡
        ¬°
        verbose_name =''',
              clss_meta='''
class Comment■
    ¬°
    class Meta''',
              clss_only='''
class Comment''',
    ),
    note='Когда ж локализации-то будут?',
    formula='not {{patten_rt.clss_good}} and ({{patten_rt.clss_meta}} or {{patten_rt.clss_only}})', 
    position='max({{patten_rt.clss_meta.btm}}, {{patten_rt.clss_only.btm}})',
),
```
*Пояснения.*  
– `{{patten_rt.clss_good}}` инфа про результат поиска clss_good:шаблоном.  
– Вычисление `not {{patten_rt.clss_good}}` будет давать Да, если поиск провалился (инфа пустая).  
– `{{patten_rt.clss_meta.btm}}` номер последней строки для найденного фрагмента (тут от clss_meta:шаблона).  
– Вычисление `max({{patten_rt.clss_meta.btm}}, {{patten_rt.clss_only.btm}})` даст нижнюю строку от одного из найденных фрагментов.
  
Ловим универсальный случай, когда `Модель.Meta.verbose_name` нет, но `Модель.Meta` или `Модель` есть.  
Варианты шаблонов заданы словарем. Запоминаем названия классов.  
```python
dict(level='E', 
    patten=dict(clss_good='''
class ┌‡‡┬name_clss_good┐■
    ¬°
    class Meta:‡
        ¬°
        verbose_name =''',
              clss_meta='''
class ┌‡‡┬name_clss_meta┐■
    ¬°
    class Meta''',
              clss_only='''
class ┌‡‡┬name_clss_only┐''',
    ),
    note='Когда ж локализации-то будут?',
    formula='"{{patten_rt.g.name_clss_good}}"=="{{patten_rt.g.name_clss_meta}}"=="{{patten_rt.g.name_clss_only}}" and '
         'not {{patten_rt.clss_good}} and ({{patten_rt.clss_meta}} or {{patten_rt.clss_only}})', 
    position='max({{patten_rt.clss_meta.btm}}, {{patten_rt.clss_only.btm}})',
),
```
*Пояснения.*  
– `‡‡` - идентификатор, т.е. словов из букво-цифр-_-точки.  
– Через `class ‡‡■` ловим имя класса.  
– `┌...┬имя┐` - запоминание подфрагмента `...` в контекстную переменную `имя`.  
– `class ┌‡‡┬name_clss_good┐` - запоминание имени класса в переменную `name_clss_good`.  
– `"{{patten_rt.g.name_clss_good}}"` - подстановка значения переменной `name_clss_good`.  
– `"{{...}}"=="{{...}}"=="{{...}}" and` - проверка совпадения имен у трех классов.  
    

### Не хватает локализации поля в модели
(*В разработке*)
### Не хватает типа у извлекаемого параметра при регистрации маршрута
(*В разработке*)
### Неудачное имя параметра при объявлении маршрута
(*В разработке*)
### Неуместное применение фильтра вместо опоры на related_name
(*В разработке*)
### Избыточное дублирование деталей кода
(*В разработке*)
### Размещение действий в неуместном методе
(*В разработке*)
### Ошибочное параллельное применение logger.error() и logging.error()
(*В разработке*)



# Технические детали  


## Структура словаря знаний (АР-словарь) <a name=rv-dict></a>  

**Внедряемые ключи** <a name=implant></a>   
Любой ключ, если не задан явно, может получить значение из окружающего словарь набора.  
Например, его можно указать  
    в `defaults` на уровне [файла](#rv-file) с этим словарем,  
    в опции [запуска](#opts).  
То есть это "вынесение за скобки" для повторяющихся значений.  

**Обязательные ключи** <a name=need-keys></a>  

- `level`/`levl` <a name=levl></a>  
    `'G'`|`'F'`|`'E'` - **G**ood/похвала, **F**alse/совет, **E**rror/ошибка.  
**Уровень** выходного комментария.  
- `patten`/`pttn` <a name=pttn></a>  
    строка|список-строк|словарь-со-строковыми-значениями  
**Шаблон(ы)** для поиска.  
В случае успешного поиска (расчет успеха может уточняться в формуле из `formula`)  
формируется номер строки (ее расчет может уточнять в формуле из `position`) для вставки комментария.  
После поиска порождает runtime-[след](#patten_rt) `patten_rt`.  
- `note` <a name=note></a>  
    строка|список-строк|словарь-со-строковыми-значениями  
Комментарий или **варианты комментариев**.  
Для первого найденного случая применяется первый комментарий, для второго - второй и т.д.  
Если случев больше и если `repeats` задан как `'all'`, то будет применяться последний вариант.  
После поиска порождает runtime-[след](#note_rt) `note_rt`.  
    
**Ожидаемые ключи** <a name=waited-keys></a>  

- `repeats`/`rpts` <a name=rpts></a>  
    `'one'`|`'all'`|`'as-note'`  
    Умолчание: `'as-note'`  
Настройка **повторных** комментирований в пределах одного файла-исходника.  
`'one'` - комментировать только первый случай.  
`'all'` - комментировать все найденные случаи, повторяя последний элемент `note` при необходимости.  
`'as-note'` - комментировать не больше, чем вариантов в `note`.  
- `formula`/`frml` <a name=frml></a>  
    Умолчание: `''`  
Текст формулы, по которой будет eval-вычисляться **успех поиска**.  
Умолчание - "есть хоть одна находка" - по формуле `any(patten_rt.values())`.  
Например, при настройке  
    `formula='{{patten_rt._0}} and {{patten_rt._2}}'`  
поиск будет успешным, если первый и третий шаблон успешны.
- `position`/`posi` <a name=posi></a>  
    Умолчание: `''`  
Текст формулы, по которой будет eval-вычисляться **номер строки** исходника для вставки.  
Умолчание - "самая нижняя строка у найденных фрагментов" - по формуле `max(p.e for p in patten_rt.values())`.  
Например,  
    `position='min({{patten_rt._0.top}}, {{patten_rt._1.btm}}, -1)'`.  
- `wo_strip` <a name=wo_strip></a>  
    Умолчание: `''` - выполнять strip-ы.  
Флаг для **пропуска** `.strip()` для всех значений у `patten` и `note`.  
Умолчание позволяет свободнее оформлять знания, но может мешать точному поиску/вставке.  
- `wait_re` <a name=wait_re></a>  
    Умолчание: `''` - ожидать сахар.  
Флаг для переключение c ожидания сахара на **ожидание регулярки**.  
Умолчание настроено на то, что регулярки появляются только внутри `«...»`.  
При любом непустом значении сахар ожидается внутри `«...»`.  
- `end_sign` <a name=end_sign></a>  
    Умолчание: `''`  
Завершающее дополнение для комментария.  
Позволяет добавлять **"подпись АР"** ко всем комментариям.  
Так как в разных файлах могут быть разные подписи, будет видно из какого файла АР брал знания.  

- `name` (идентификатор) <a name=name></a>  
    Умолчание: `''`  
Имя контекстной **переменной для подстановок** в другие знания.  
Например, `name='имя'` позволит подставлять в других АР-словарях  
    `{{имя.level}}` или `{{имя.note}}` или `{{имя.note_rt._1 }}`.  
Можно организовывать цепочки знаний и/или условные комментирования.  

**Runtime-след - ключи, доступные только после выполнения поиска** <a name=rt-keys></a>  
Для каждого нового исходника эти ключи заполняются заново.  

- `patten_rt`/`pttn_rt` <a name=pttn_rt></a>  
    словарь словарей  
Словарь (мб с пустыми элементами!), содержащий инфо про **найденные фрагменты** *для первого случая* 
(и первый и все остальные случаи попадают в `usages`).  
Если `patten` был задан списком, то ключами станут `_позиция`:  
    `{'_0':{инфо},'_1':{},}`  
Если `patten` уже был словарем, то ключи сохранятся.  
Внутри инфо будут такие ключи  
– `'top':номер-строки-на-начало-найденного-фрагмента`,  
– `'btm':номер-строки-на-конец-найденного-фрагмента`,  
– `'g':найденный-фрагмент`,  
– `'g.имя':фрагмент-найденной-групы-с-указанным-именем`.  
Если шаблон неуспешен, то формируется пустой словарь, но обращения к его ключам будут работать:  
    `'top'` и `'btm'` дадут -1, `'g'` и `'g.имя'` дадут пустую строку,  
В словаре сохраняются только именованные re-группы, в том числе с [сахар-именами](#frag-name) фрагментов.

- `note_rt` <a name=note_rt></a>  
    словарь словарей  
Рассчитанные **комментарии** *для первого случая* 
(и первый и все остальные случаи попадают в `usages`).  
Ключи либо `_позиция`, если `note` был задан списком, либо ключи от `note`.  

- `usages` <a name=usages></a>  
    список словарей  
Список всех успешных **применений**, содержащий словари с ключами `'patten_rt'` и `'note_rt'`.  
Набор `usages` не пуст, если было хоть одно успешное применение.  
В этом случае в  
    `usages.0.patten_rt` и `patten_rt` совпадают,  
    `usages.0.note_rt` и `note_rt` совпадают.  

**Модификаторы значений**  

**Подстановки** <a name=subs-mod></a>  
Любое значение (в том числе из списка/словаря) у обязательных/ожидаемых ключей (кроме `formula` и `position`) может 
начинаться с модификаторов  
- `+t:`  
Нужны подстановки вида `{{имя}}`, где "имя" указывает на контектную переменную.  
- `+t{{{}}}:`  
Нужны подстановки вида `{{{имя}}}`.  
- `+te:`  
После подстановок вида `{{имя}}` требуется `eval()`.  
- `+te<<>>:`  
После подстановок вида `<<имя>>` требуется `eval()`.  

Между `+t`/`+te` и `:` могут указываться явные "парные скобки" для выделения имени подставляемого значения.  
Умолчательные "парные скобки" - `{{}}`.  
Пример.  
```python
dict(...,patten='lala',name='nm',...),                  # ищем lala
dict(...,patten='+t:def {{nm.patten}}{{nm.patten}}(',...),  # ищем lalalala в питоне
dict(...,patten='+t<<>>:<br>{{it}} <<nm.patten>> ',...),  # ищем lala в шаблоне
dict(...,patten='+te:"{{nm.patten}}"[:2]',...),           # ищем la
```
  
Для значений у `formula` и `position` эти модификаторы избыточны, так как eval применятся всегда и 
необходимости менять `{{}}` нет.  


**Локализации** <a name=pttn_ast></a>  
Значения из `patten` могут содержать указания на анализ локализации в AST-дереве.   
Для этого они должны начинаться с модификатора:  
    `'+ast-in:'`  
Тогда в rt-следе для этого значения появится новый ключ  
    `'ast':'локализация'`  
с одним из значений  
    `''` - нет однозначной локализации,  
    `'str'` - фрагмент локализован внутри строкового литерала,  
    `'com'` - фрагмент локализован внутри комментария,  
    `'doc'` - фрагмент локализован внутри док-строки.  
  
Значения из `patten` могут содержать конкретные ограничения на локализацию в AST-дереве.   
Для этого они должны начинаться с одного из модификаторов:  
    `'+ast-in-str:'` - весь найденный фрагмент должен находиться внутри строкового литерала.  
    `'+ast-in-com:'` - весь найденный фрагмент должен находиться внутри комментария.  
    `'+ast-in-doc:'` - весь найденный фрагмент должен находиться внутри док-строки.  
При этом в rt-след всегда добавляется ключ `'ast':'локализация'` 
и умолчательная формула `formula` дополняется его анализом.  
  
Модификаторы локализаций размещаются раньше модификаторов подстановок.  
  
Примеры.  
- Поиск `om` только в виде `par='home'`, но не в виде `home='par'`.  
   ```python
   dict(...,patten='om',formula='+ast-in-str:',...),
   ```
- Поиск `om` только внутри комментариев и док-строк.  
   ```python
   dict(...,patten='om',formula='+ast-in:+te:"{{patten_rt.ast}}" in "com doc"',...),
   ```


## Структура файла знаний с АР-словарями <a name=rv-file></a>  
Файл должен содержать один словарь вида  
```python
{
   'defaults': {
      'ключ-АР-словаря': 'значение',
      'ключ-АР-словаря': 'значение',
   },
   'регулярка-на-путь-внутри-zip-к-файлу-исходника': [
      список-АР-словарей
   ],
   'регулярка-на-путь-внутри-zip-к-файлу-исходника': [
      список-АР-словарей
   ],
}
```

- Часть `defaults:{}` необязательная.  
Внутри могут указываться любые [обязательные](#need-keys) и [ожидаемые](#waited-keys) ключи АР-словаря, 
в том числе, неописанные в этом доке.  
Всем указанным тут ключам во всех АР-словарях **этого файла** будут назначены указанные значения, 
**если** ключа в АР-словаре нет.

   Примеры.  
   - Можно инвертировать размещения сахаров и регулярок в [изоляторах](#do-sugar) `«...»` 
   через `'wait_re':'T'`.  
   - Можно всем комментариям один раз задать уровень **Надо исправить** через `'level':'E'`, 
   а для некоторых потом явно указывать другие уровни.  
   - Удобно для разных файлов назначить разные "подписи АР" через `end_sign`.  
   Тогда будет видно "из какого файла" АР брал комментарий. 
   - Можно поменять умолчательное место для вставки комментария:  
       с последней найденной строки  
       на первую,  
   указав формулу через `position`.  

- Интерференция регулярок.  
   Будут применяться все АР-словари:    
   - Одна регулярка может отбирать несколько путей для исходников.   
   - Один путь к исходнику может подходить нескольким регуляркам.  
   
   Гарантируется, что применения будут в порядке, указанном в файле сверху-вниз.  


## Сборка знаний для одной домашки <a name=build></a>  
1. Внутри zip для одного типа домашек файлы, которые нужно обрабатывать, оказываются в разных папках.  
Это происходит из-за свободы на стороне студентов - они вольны именовать/выбирать ветку в репо 
или даже сдавать вообще самостоятельно собранным архивом.  
Кроме того, общие файлы у серии домашек (Блог-1/2/3, ДРФ-1/2, Фаст-1/2) оказываются размещены 
в разных корневых папках, так как меняется репо.
1. Знания для одного типа домашек почти всегда размещены в нескольких файлах.  
Например, выгодно держать претензии в языку отдельно и включать во все ревью.  
Кроме того, выгодно применять знания от предыдущей домашки из серии.

Поэтому сборка знаний для одной домашки указывает на
– все ожидаемые корневые папки в zip,
– все участвующие в обработках файлы знаний.
АР выполняет попытки применить каждый файл знаний к каждой из корневых папок.

**Оформление**  
В [настройках](#opts) АР за эту сборку отвечает ключ `build_skills` из `opts`:  
```python
opts = dcta(
    build_skills=dcta(
        ключ-домашки=dcta(
            main_dirs_in_zip=[перечисление-ожидаемых-папок],
            skills=[перечисление-нужных-файлов-знаний],
        ),
    ),
)
```
Замечания

1. Ключи домашек задаются в других частях настройки.
1. Ожидаемую в zip папку можно указать явно через опцию запуска `-hd`/`--hw_dir`.  
Тогда список для `main_dirs_in_zip` будет заполнен только этим значением.
1. Файлы в списке по `skills` указываются по абсолютным либо по относительным путям.  

Пример.  
```python
opts = dcta(
    build_skills=dcta(
        bot=dcta(
            main_dirs_in_zip=['homework_bot-master', 'bot-master', ],
            skills=[
                'skills/_bs0_skills2.py',
                'skills/bot_skills2.py',
            ],
        ),
    ),
)
```


## Слияния комментариев от нескольких АР-словарей <a name=merge></a>  
Если к одной строке исходника АР нашел несколько вариантов комментариев, 
то умолчательный алгоритм их смешивания такой:

- Общий уровень комментария задается  
   - как **Отлично**, если такой есть среди вариантов,  
   - иначе как **Надо исправить**, если такой есть среди вариантов.  
- Сначала размещаются варианты с выбранным общим уровнем.  
- За ними размещаются варианты с одинаковыми уровнями: от **Можно лучше** к **Надо исправить**.  
- Если вариантов с общим уровнем несколько, они оформляются a-la "нумерованным" списком:  
   - добавляется разделяющая пустая строка,  
   - добавляется в начало комментария `(N) `, где N его номер в группе с одинаковым уровнем.  

Пример 1.  
Есть набор для комментирования:  
    F, 'false 1'  
    F, 'false 2'  
    G, 'good'  
    E, 'error'  
Тогда комментарий получится такой
```
   good
   
   **Можно лучше**
   (1) false 1
   
   (2) false 2
   
   **Надо исправить**
   error
   
      Отлично
```
Пример 2.  
Есть набор для комментирования:  
    F, 'false 1'  
    E, 'error 1'  
    E, 'error 2'  
Тогда комментарий получится такой
```
   (1) error 1
   
   (2) error 2
   
   **Можно лучше**
   false 1
   
      Надо исправить
```

## Сахара  

### Порядок применения <a name=do-sugar></a>  
- Выделяются сахарные части.  
Они могут быть вне (умолчание) или внутри изоляторов `«...»` в зависимости от `wait_re`.  
- Для каждой сахарной части  
   - Экранируются все знаки натур-регулярок.  
   - В цикле пока происходит хоть одна замена:  
      - Выполняются подмены всех свободных сахаров.  
      - Выполняются подмены всех зашитых сахаров.  

Цикл по заменам означает, что в подменяемой части могут оказываться 
новые сахара - как свободные, так и зашитые.

### Зашитые (неподменяемые!) сахара <a name=in-sugar></a>
- `«шаблон»` - **изолятор** <a name=isolator></a>  
В зависимости от значения ключа `wait_re` внутри "лапок" может быть  
    питон-регулярка (если `wait_re` пустой),  
    сахарная разметка (при непустом `wait_re`).  
Изоляторы не могут быть вложенными, но могут появляться при замене свободных сахаров.
- `‡` - **стяжка** <a name=strap></a>  
Минимальный заполняющий текст (возможно пустой), в том числе, содержащий концы строк.  
- `(‡)` `[‡]` `{‡}` - **фрагмент в парных скобках** <a name=bracks></a>  
От открывающей до ее *парной* закрывающей.  
- `¬°` - **на том же уровне отступа** <a name=same-gap></a>  
Фрагмент из нескольких строк (м.б. 0) с такими же (не меньше) сдвигами у начала текста.  
- `!<так¦этак¦эдак>!` - **варианты фрагментов** <a name=vars></a>  
Указываются варианты разметки.  
Ограничение: внутри вариантов не должно быть `!<` `¦` `>!`.  
- `╠фраза╣` - **лишний текст перед чем-то** <a name=no-frag></a>  
Фразы не должно быть *перед следующим* подходящим символом.  
- `↓1` `↓2` ... `↓9` - **номера найденных строк** <a name=row-num></a>  
Запоминание номера строки, в которой находится такой знак.  
Эти номера можно будет вставлять в комментарии - там они будут доступны под похожими обозначениями  
    `↓1↓` `↓2↓` ... `↓9↓`  
Если поисковых шаблонов несколько, то имена для вставок могут содержать явные указания  
    `↓1↓` - от первого элемента `patten`.  
    `↓_0.1↓` - от первого элемента, если `patten` задан списком.  
    `↓ключ.1↓` - от элемента `patten` с ключом `ключ`.  
- `┌сахар┬имя┐` - **имя подфрагмента** <a name=frag-name></a>  
Назначение имени для найденного подфрагмента.
Назначенное имя можно будет применять в через `patten_rt.g.имя` в ключах АР-словаря.

Применяются такие регулярные выражения

| Символ        | Регулярка или применение в заменах | Комментарий |
| --            | --                   | -- |
| `‡`           | `(?s:.*?)`           | Общий знак `‡` тут и ниже |
| `(‡)`         | `\([^\(\)]*?(?:\([^\(\)]*?(?:\([^\(\)]*?\)[^\(\)]*?)*?\)[^\(\)]*?)*?\)` | Глубина вложенности <3|
| `[‡]`         | `\[[^\[\]]*?(?:\[[^\[\]]*?(?:\[[^\[\]]*?\][^\[\]]*?)*?\][^\[\]]*?)*?\]` | Глубина вложенности <3|
| `{‡}`         | `\{[^\{\}]*?(?:\{[^\{\}]*?(?:\{[^\{\}]*?\}[^\{\}]*?)*?\}[^\{\}]*?)*?\}` | Глубина вложенности <3|
| `¬°`          | `\n( *)¬°` заменяется на `(\n\\1.*)*` |  |
| `!<` `¦` `>!` | `!<([^¦]+)¦([^>!]+)>!` заменяется на `((\\1)\|(\\2))` (остальные аналогично) | Ожидаются <10 вариантов |
| `╠` `╣`       | `╠` заменяется на `(?<!`, `╣` заменяется на `)`| |
| `↓0` `↓1` ... | `↓(\d+)` заменяется на `(?P<p\1>(?<!↓))` | Не будет найденных символов | 
| `┌...┬n┐`     | ... заменяется на ... |  | 

### Свободные (подменяемые!) сахара <a name=free-sugar></a>
Умолчательный набор указывается в `autorv2_free_sugars.py`.  
Там же можно удалять, подменять значения или добавлять свои сахара.  
  
Умолчательный набор  

- `‡‡` - **часть идентификатора**  
Текст (возможно пустой) из букв/цифр/_/точки.  
- `■` - **заполнитель**  
Любой непустой текст в пределах строки.  
- `□` - **заполнитель**  
Любой текст в пределах строки.  
- `○` - **пробельные символы**  
Несколько пробелов/табов/EOL (может быть 0).  
- `▫` - **пробелы**  
Несколько пробелов (может быть 0).  
- `▪` - **обязательные пробелы**  
Несколько пробелов/табов/EOL.  
- `†` - **кавычка**  
Либо `'`, либо `"`.  

Применяются такие регулярные выражения  

| Символ        | Регулярка  | Комментарий |
| --            | --         | -- |
| `‡‡`          | `[\w\.]*`  | Может быть другой знак |
| `†`           | `[\'\"]`   | |
| `□`           | `.*`       | Мнемоника: пустой символ = "от 0"|
| `■` `▬`       | `.+`       | Мнемоника: непустой символ = "от 1"|
| `○`           | `\s*`      | Мнемоника: пустой символ = "от 0"|
| `▪` `¶±`      | `\s+`      | Мнемоника: непустой символ = "от 1"|
| `▫` `…`       | ` *`       | Мнемоника: пустой символ = "от 0"|


## Порядок обработки и контекстные переменные <a name=actions></a>  


### Порядок обработок <a name=order></a>  
1. Каждый исходный файл из zip обрабатывается назависимо.  
В частности, нет возможности предсказывать какой их двух файлов будет обработан первым.  
1. Порядок применения АР-словарей для одного исходного файла жесткий.  
   - Гарантируется, что АР-словари внутри одного файла знаний будут обрабатываться сверху вниз.  
   - Порядок применения разных файлов знаний фиксирован в [сборке](#build).  
1. АР-словари могут опираться на результаты применения предыдущих АР-словарей, если у них задан [ключ](#name) `name`.  

### Контекстные переменные <a name=context></a>  
Подстановка `{{ЛюБоЕиМя}}` никогда не дает сбоя, если в контексте нет такой переменной.  
Если такая переменная может быть в контексте, например, это ключ АР-словаря, то будет подставляться умолчание.  
В остальных случаях будет подставляться пустая строка.

**Глобальные контекстные переменные** <a name=global-context></a>  
- `{{HW_ZIP_PATH}}` - **полный путь** к исходному zip.
- `{{HW_ZIP_FN}}` - **имя файла** без расширения от zip.
- `{{HW_ITER}}` - **номер итерации** (добавит [Монитор](#monitor), если он вызывает АР).
- От [настроек](#opts) (в том числе от опций запуска) могут поступать дополнительные глобалы.

**Внутренние переменные АР-словарей** <a name=dict-context></a>  
- Внутри одного АР-словаря для `formula`, `position` и остальных значений с [подстановками](#subs-mod) доступны все [ключи](#rv-dict), как контекстные переменные с такими же именами:
   - `{{level}}`, `{{patten}}`, `{{note}}` и т.д., в том числе [rt-следы](#rt-keys)  
   `{{patten_rt}}`, `{{note_rt}}`, `{{usages}}`.
   - Если значение список, то доступ по именам `{{patten._0}}`, `{{patten._1}}` и т.д.  
   При этом совпадают `{{patten}}` и `{{patten._0}}`.
   - Если значение словарь, то доступ по его ключам `{{patten.ключ}}`, `{{patten.еще}}` и т.д.  
   При этом совпадают `{{patten}}` и `{{patten.первый-ключ}}`.
- От предыдущего (см выше) АР-словаря с заданым ключом `name='имя'` доступны все эти же данные с префиксом `имя.`  
   - `{{имя.level}}`, `{{имя.patten}}`, `{{имя.note}}` и т.д.

## Система настроек. Конфиг-файлы и опции запуска <a name=opts></a>  
(*ДОКУМЕНТАЦИЯ В РАЗРАБОТКЕ*)
- Код имеет умолчательные настройки, которые могут быть изменены в любой части через внешний json.
- Каждый из символов в спец.разметке может быть заменен на любую строку 
(но не всякая строках, конечно, уместна, так как поиски будут вестись через регулярки).
- С каждым из файлов в архиве может быть связан произвольный файл (или несколько) с наборами АР-словарей.
- Файлы с наборами АР-словарей могут быть 
  - в виде питон-кода 
  `{'hw02_community-master/yatube/posts/models.py':[dict(...), dict(...),]}`
  - в виде yaml

```yaml
"hw02_community-master/yatube/posts/models.py":
- level: F
  patten: |2-
    group = models.ForeignKey(…
        ¬°
        related_name=†!<groups¦group>!†
  note: "Неудачное имя для поля связи."
```

  - в виде json (м.б. кому-то это окажется полезно)



# Дополнительные сервисы


## Монитор для автоматического запуска АР <a name=monitor></a>  
При запуске

    `python autorv2.py -m папка-с-именами-студентов`

происходит зацикливание, при котором АР-Монитор наблюдает за указанной папкой и папками вхоженными в нее.

Отслеживаются:
- Создание новой подпапки (добавился студент).
- Появление в подпапке нового zip (скачана новая домашка).

Действия при появлении нового zip регулируются через настройку `opts.monitor`.

Умолчательный набор действий зашит в код АР. Он может включать:
- Распаковку zip-а.
- Переименование папки с домашкой, чтобы итерации различать.
- Запуск АР для создания нового zip-а.
- Запуск сравнивающей две папки утилиты (типа WinMerge), 
если есть папка с предыдущей итерацией (в том числе из предыдущего ДЗ в цепочке).


## Демонстрация окончательного вида одного шаблона - подмены всех сахаров
При запуске

    `python autorv2.py -ds путь-файла-знаний::путь-по-знаниям`

из json-данных в указанном файле будет извлечено значение и после замены сахара на регулярки выдано 
в соседний файл

    `путь-файла-знаний.desugar_ГГ-ММ-ДД_ЧЧ-ММ-СС.py`

Путь внутри json записывается с разделителем `|`.  
Спуск в словаре выглядит так  
    `путь-до-словаря|ключ`  
Спуск в списке выглядит так  
    `путь-до-списка|номер-позиции`  

Пример. В знаниях к ДЗ-2 `hw02_skills.py` есть 
```python
'posts/models.py':[
dict(level='G',
    formula='ITER < 2 and m_0',
    patten='''
    group = models.ForeignKey(‡
        on_delete=models.SET_NULL''',
    note='''Удачно.''',
),
dict(level='G',
    patten='''
    group = models.ForeignKey(‡
        related_name=†posts†''',
    note='''Правильно!''',
),

```
После запуска  
    `python autorv.py -ds "path/hw02_skills.py::posts/models.py|1|ptth"`  
появится файл  
    `path/hw02_skills.py.desugar_23-01-14_01-27-07.py`  
с готовой для тестирования регуляркой. Содержимое файла
```
import re

# Регулярка c сахаром
patten = r"""{patten}"""

# Регулярка без сахара
patten = r"""{dspatten}"""

# Задайте тестируемый текст из ДЗ
src = """ """ 
#src = open(r'путь к исходнику в ДЗ', encoding='utf8').read()

# Запуск теста
mt  = re.search(patten, src)
if not mt:return print('fail')
print(mt.groupdict())
```

### Рекомендуемый способ применения
Чтобы не заморачиваться с расчетом пути до нужного patten в полном json-дереве,  
можно завести один пи-исходник `ds.py` с тривиальным наполненем  
    ["""шаблон"""]  
копировать в него нужный для отладки patten и запускать конвертацию всегда одинаково  
    `python autorv.py -ds ds.py::0`


## Известные проблемы
- Ревизор глотает начальные пробелы в комментах.  
Поэтому АР меняет левый пробел на символ `·`.  
В результате примеры кодов/разметки в комментах оказываются некорректными.  
Ждем исправления Ревизора.

## (ToDo) В планах
- Обмен вычисленными значениями между найденными случаями.
- Добавить элементы AST-флагов в знания: указывать "в комментарии" или "внутри строкового литерала".
- Добавить "человеко-пальце-любивые" синонимы для сахаров.
- Добавить "внятные" синонимы для ключей АР-словаря.
- Добавить примеры поисков регулярками и их записи сахарами.


## История обновлений
### 2.0.100 29feb24
- [+] Старт разработки
